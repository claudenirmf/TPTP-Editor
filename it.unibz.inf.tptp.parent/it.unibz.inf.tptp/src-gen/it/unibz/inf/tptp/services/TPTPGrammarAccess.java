/*
 * generated by Xtext 2.12.0
 */
package it.unibz.inf.tptp.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class TPTPGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTPTP_inputAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTPTP_inputIncludeParserRuleCall_0_0 = (RuleCall)cTPTP_inputAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cTPTP_inputAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cTPTP_inputFof_inputParserRuleCall_1_0_0 = (RuleCall)cTPTP_inputAssignment_1_0.eContents().get(0);
		private final Assignment cTPTP_inputAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cTPTP_inputTff_inputParserRuleCall_1_1_0 = (RuleCall)cTPTP_inputAssignment_1_1.eContents().get(0);
		private final Assignment cTPTP_inputAssignment_1_2 = (Assignment)cAlternatives_1.eContents().get(2);
		private final RuleCall cTPTP_inputCnf_inputParserRuleCall_1_2_0 = (RuleCall)cTPTP_inputAssignment_1_2.eContents().get(0);
		private final Assignment cTPTP_inputAssignment_1_3 = (Assignment)cAlternatives_1.eContents().get(3);
		private final RuleCall cTPTP_inputThf_inputParserRuleCall_1_3_0 = (RuleCall)cTPTP_inputAssignment_1_3.eContents().get(0);
		
		////grammar com.theoremsandstuff.tptp.Parser hidden(WS, ML_COMMENT, SL_COMMENT)
		////
		////import "http://www.eclipse.org/emf/2002/Ecore" as ecore
		////generate parser "http://www.theoremsandstuff.com/tptp/Parser"
		////generate parser "http://www.unibz.it/inf/"
		//Model:
		//	TPTP_input+=Include* (TPTP_input+=Fof_input* | TPTP_input+=Tff_input* | TPTP_input+=Cnf_input* |
		//	TPTP_input+=Thf_input*);
		@Override public ParserRule getRule() { return rule; }
		
		//TPTP_input+=Include* (TPTP_input+=Fof_input* | TPTP_input+=Tff_input* | TPTP_input+=Cnf_input* | TPTP_input+=Thf_input*)
		public Group getGroup() { return cGroup; }
		
		//TPTP_input+=Include*
		public Assignment getTPTP_inputAssignment_0() { return cTPTP_inputAssignment_0; }
		
		//Include
		public RuleCall getTPTP_inputIncludeParserRuleCall_0_0() { return cTPTP_inputIncludeParserRuleCall_0_0; }
		
		//TPTP_input+=Fof_input* | TPTP_input+=Tff_input* | TPTP_input+=Cnf_input* | TPTP_input+=Thf_input*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//TPTP_input+=Fof_input*
		public Assignment getTPTP_inputAssignment_1_0() { return cTPTP_inputAssignment_1_0; }
		
		//Fof_input
		public RuleCall getTPTP_inputFof_inputParserRuleCall_1_0_0() { return cTPTP_inputFof_inputParserRuleCall_1_0_0; }
		
		//TPTP_input+=Tff_input*
		public Assignment getTPTP_inputAssignment_1_1() { return cTPTP_inputAssignment_1_1; }
		
		//Tff_input
		public RuleCall getTPTP_inputTff_inputParserRuleCall_1_1_0() { return cTPTP_inputTff_inputParserRuleCall_1_1_0; }
		
		//TPTP_input+=Cnf_input*
		public Assignment getTPTP_inputAssignment_1_2() { return cTPTP_inputAssignment_1_2; }
		
		//Cnf_input
		public RuleCall getTPTP_inputCnf_inputParserRuleCall_1_2_0() { return cTPTP_inputCnf_inputParserRuleCall_1_2_0; }
		
		//TPTP_input+=Thf_input*
		public Assignment getTPTP_inputAssignment_1_3() { return cTPTP_inputAssignment_1_3; }
		
		//Thf_input
		public RuleCall getTPTP_inputThf_inputParserRuleCall_1_3_0() { return cTPTP_inputThf_inputParserRuleCall_1_3_0; }
	}
	public class IncludeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Include");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIncludeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cPathAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPathSTRINGTerminalRuleCall_2_0 = (RuleCall)cPathAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cFullStopKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Include:
		//	'include' '(' path=STRING ')' '.';
		@Override public ParserRule getRule() { return rule; }
		
		//'include' '(' path=STRING ')' '.'
		public Group getGroup() { return cGroup; }
		
		//'include'
		public Keyword getIncludeKeyword_0() { return cIncludeKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//path=STRING
		public Assignment getPathAssignment_2() { return cPathAssignment_2; }
		
		//STRING
		public RuleCall getPathSTRINGTerminalRuleCall_2_0() { return cPathSTRINGTerminalRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
		
		//'.'
		public Keyword getFullStopKeyword_4() { return cFullStopKeyword_4; }
	}
	public class Fof_inputElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Fof_input");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFof_rootParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIncludeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Fof_input:
		//	Fof_root | Include;
		@Override public ParserRule getRule() { return rule; }
		
		//Fof_root | Include
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Fof_root
		public RuleCall getFof_rootParserRuleCall_0() { return cFof_rootParserRuleCall_0; }
		
		//Include
		public RuleCall getIncludeParserRuleCall_1() { return cIncludeParserRuleCall_1; }
	}
	public class Fof_rootElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Fof_root");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFofKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cNameAlternatives_2_0 = (Alternatives)cNameAssignment_2.eContents().get(0);
		private final RuleCall cNameLower_token_and_keywordParserRuleCall_2_0_0 = (RuleCall)cNameAlternatives_2_0.eContents().get(0);
		private final RuleCall cNameSTRINGTerminalRuleCall_2_0_1 = (RuleCall)cNameAlternatives_2_0.eContents().get(1);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cFormula_roleAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final Alternatives cFormula_roleAlternatives_4_0 = (Alternatives)cFormula_roleAssignment_4.eContents().get(0);
		private final Keyword cFormula_roleAxiomKeyword_4_0_0 = (Keyword)cFormula_roleAlternatives_4_0.eContents().get(0);
		private final Keyword cFormula_roleHypothesisKeyword_4_0_1 = (Keyword)cFormula_roleAlternatives_4_0.eContents().get(1);
		private final Keyword cFormula_roleNegated_conjectureKeyword_4_0_2 = (Keyword)cFormula_roleAlternatives_4_0.eContents().get(2);
		private final Keyword cFormula_roleConjectureKeyword_4_0_3 = (Keyword)cFormula_roleAlternatives_4_0.eContents().get(3);
		private final Keyword cFormula_roleDefinitionKeyword_4_0_4 = (Keyword)cFormula_roleAlternatives_4_0.eContents().get(4);
		private final Keyword cFormula_roleLemmaKeyword_4_0_5 = (Keyword)cFormula_roleAlternatives_4_0.eContents().get(5);
		private final Keyword cCommaKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cExpAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cExpFof_expressionParserRuleCall_6_0 = (RuleCall)cExpAssignment_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Keyword cFullStopKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//Fof_root:
		//	'fof' '('
		//	name=(Lower_token_and_keyword | STRING)
		//	',' formula_role=('axiom' | 'hypothesis' | 'negated_conjecture'
		//	| 'conjecture' | 'definition' | 'lemma')
		//	',' exp=Fof_expression
		//	')' '.';
		@Override public ParserRule getRule() { return rule; }
		
		//'fof' '(' name=(Lower_token_and_keyword | STRING) ',' formula_role=('axiom' | 'hypothesis' | 'negated_conjecture' |
		//'conjecture' | 'definition' | 'lemma') ',' exp=Fof_expression ')' '.'
		public Group getGroup() { return cGroup; }
		
		//'fof'
		public Keyword getFofKeyword_0() { return cFofKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//name=(Lower_token_and_keyword | STRING)
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//(Lower_token_and_keyword | STRING)
		public Alternatives getNameAlternatives_2_0() { return cNameAlternatives_2_0; }
		
		//Lower_token_and_keyword
		public RuleCall getNameLower_token_and_keywordParserRuleCall_2_0_0() { return cNameLower_token_and_keywordParserRuleCall_2_0_0; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_2_0_1() { return cNameSTRINGTerminalRuleCall_2_0_1; }
		
		//','
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//formula_role=('axiom' | 'hypothesis' | 'negated_conjecture' | 'conjecture' | 'definition' | 'lemma')
		public Assignment getFormula_roleAssignment_4() { return cFormula_roleAssignment_4; }
		
		//('axiom' | 'hypothesis' | 'negated_conjecture' | 'conjecture' | 'definition' | 'lemma')
		public Alternatives getFormula_roleAlternatives_4_0() { return cFormula_roleAlternatives_4_0; }
		
		//'axiom'
		public Keyword getFormula_roleAxiomKeyword_4_0_0() { return cFormula_roleAxiomKeyword_4_0_0; }
		
		//'hypothesis'
		public Keyword getFormula_roleHypothesisKeyword_4_0_1() { return cFormula_roleHypothesisKeyword_4_0_1; }
		
		//'negated_conjecture'
		public Keyword getFormula_roleNegated_conjectureKeyword_4_0_2() { return cFormula_roleNegated_conjectureKeyword_4_0_2; }
		
		//'conjecture'
		public Keyword getFormula_roleConjectureKeyword_4_0_3() { return cFormula_roleConjectureKeyword_4_0_3; }
		
		//'definition'
		public Keyword getFormula_roleDefinitionKeyword_4_0_4() { return cFormula_roleDefinitionKeyword_4_0_4; }
		
		//'lemma'
		public Keyword getFormula_roleLemmaKeyword_4_0_5() { return cFormula_roleLemmaKeyword_4_0_5; }
		
		//','
		public Keyword getCommaKeyword_5() { return cCommaKeyword_5; }
		
		//exp=Fof_expression
		public Assignment getExpAssignment_6() { return cExpAssignment_6; }
		
		//Fof_expression
		public RuleCall getExpFof_expressionParserRuleCall_6_0() { return cExpFof_expressionParserRuleCall_6_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }
		
		//'.'
		public Keyword getFullStopKeyword_8() { return cFullStopKeyword_8; }
	}
	public class Fof_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Fof_expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cFof_terminating_expressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpBinary_operatorParserRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightFof_terminating_expressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Fof_expression:
		//	Fof_terminating_expression ({binary.left=current} op=Binary_operator right=Fof_terminating_expression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Fof_terminating_expression ({binary.left=current} op=Binary_operator right=Fof_terminating_expression)*
		public Group getGroup() { return cGroup; }
		
		//Fof_terminating_expression
		public RuleCall getFof_terminating_expressionParserRuleCall_0() { return cFof_terminating_expressionParserRuleCall_0; }
		
		//({binary.left=current} op=Binary_operator right=Fof_terminating_expression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{binary.left=current}
		public Action getBinaryLeftAction_1_0() { return cBinaryLeftAction_1_0; }
		
		//op=Binary_operator
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//Binary_operator
		public RuleCall getOpBinary_operatorParserRuleCall_1_1_0() { return cOpBinary_operatorParserRuleCall_1_1_0; }
		
		//right=Fof_terminating_expression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Fof_terminating_expression
		public RuleCall getRightFof_terminating_expressionParserRuleCall_1_2_0() { return cRightFof_terminating_expressionParserRuleCall_1_2_0; }
	}
	public class Fof_terminating_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Fof_terminating_expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cFof_atomAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cFof_atomFof_atomParserRuleCall_0_0 = (RuleCall)cFof_atomAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cFof_expressionParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Assignment cFof_negationAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final Keyword cFof_negationTildeKeyword_2_0_0 = (Keyword)cFof_negationAssignment_2_0.eContents().get(0);
		private final Assignment cFof_expAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cFof_expFof_expressionParserRuleCall_2_1_0 = (RuleCall)cFof_expAssignment_2_1.eContents().get(0);
		private final Assignment cFof_expAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cFof_expFof_quantifier_expressionParserRuleCall_3_0 = (RuleCall)cFof_expAssignment_3.eContents().get(0);
		
		//Fof_terminating_expression Fof_expression:
		//	fof_atom=Fof_atom |
		//	'(' Fof_expression ')' | fof_negation?='~' fof_exp=Fof_expression | fof_exp=Fof_quantifier_expression;
		@Override public ParserRule getRule() { return rule; }
		
		//fof_atom=Fof_atom | '(' Fof_expression ')' | fof_negation?='~' fof_exp=Fof_expression |
		//fof_exp=Fof_quantifier_expression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//fof_atom=Fof_atom
		public Assignment getFof_atomAssignment_0() { return cFof_atomAssignment_0; }
		
		//Fof_atom
		public RuleCall getFof_atomFof_atomParserRuleCall_0_0() { return cFof_atomFof_atomParserRuleCall_0_0; }
		
		//'(' Fof_expression ')'
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//Fof_expression
		public RuleCall getFof_expressionParserRuleCall_1_1() { return cFof_expressionParserRuleCall_1_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
		
		//fof_negation?='~' fof_exp=Fof_expression
		public Group getGroup_2() { return cGroup_2; }
		
		//fof_negation?='~'
		public Assignment getFof_negationAssignment_2_0() { return cFof_negationAssignment_2_0; }
		
		//'~'
		public Keyword getFof_negationTildeKeyword_2_0_0() { return cFof_negationTildeKeyword_2_0_0; }
		
		//fof_exp=Fof_expression
		public Assignment getFof_expAssignment_2_1() { return cFof_expAssignment_2_1; }
		
		//Fof_expression
		public RuleCall getFof_expFof_expressionParserRuleCall_2_1_0() { return cFof_expFof_expressionParserRuleCall_2_1_0; }
		
		////TODO: fix nesting expression problem
		//fof_exp=Fof_quantifier_expression
		public Assignment getFof_expAssignment_3() { return cFof_expAssignment_3; }
		
		//Fof_quantifier_expression
		public RuleCall getFof_expFof_quantifier_expressionParserRuleCall_3_0() { return cFof_expFof_quantifier_expressionParserRuleCall_3_0; }
	}
	public class Fof_atomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Fof_atom");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFof_constantParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFof_varParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cFof_atom_literalParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Fof_atom:
		//	Fof_constant | Fof_var | Fof_atom_literal;
		@Override public ParserRule getRule() { return rule; }
		
		//Fof_constant | Fof_var | Fof_atom_literal
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Fof_constant
		public RuleCall getFof_constantParserRuleCall_0() { return cFof_constantParserRuleCall_0; }
		
		//Fof_var
		public RuleCall getFof_varParserRuleCall_1() { return cFof_varParserRuleCall_1; }
		
		//Fof_atom_literal
		public RuleCall getFof_atom_literalParserRuleCall_2() { return cFof_atom_literalParserRuleCall_2; }
	}
	public class Fof_atom_literalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Fof_atom_literal");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cNameAlternatives_0 = (Alternatives)cNameAssignment.eContents().get(0);
		private final Keyword cNameTrueKeyword_0_0 = (Keyword)cNameAlternatives_0.eContents().get(0);
		private final Keyword cNameFalseKeyword_0_1 = (Keyword)cNameAlternatives_0.eContents().get(1);
		
		//Fof_atom_literal Fof_constant:
		//	name=('$true' | '$false');
		@Override public ParserRule getRule() { return rule; }
		
		//name=('$true' | '$false')
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//('$true' | '$false')
		public Alternatives getNameAlternatives_0() { return cNameAlternatives_0; }
		
		//'$true'
		public Keyword getNameTrueKeyword_0_0() { return cNameTrueKeyword_0_0; }
		
		//'$false'
		public Keyword getNameFalseKeyword_0_1() { return cNameFalseKeyword_0_1; }
	}
	public class Fof_constantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Fof_constant");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cNameAlternatives_0_0 = (Alternatives)cNameAssignment_0.eContents().get(0);
		private final RuleCall cNameLower_token_and_keywordParserRuleCall_0_0_0 = (RuleCall)cNameAlternatives_0_0.eContents().get(0);
		private final RuleCall cNameSTRINGTerminalRuleCall_0_0_1 = (RuleCall)cNameAlternatives_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cFof_paramAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cFof_paramFof_atomParserRuleCall_1_1_0 = (RuleCall)cFof_paramAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cCommaKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cFof_paramAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cFof_paramFof_atomParserRuleCall_1_2_1_0 = (RuleCall)cFof_paramAssignment_1_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//Fof_constant:
		//	name=(Lower_token_and_keyword | STRING) ('(' fof_param+=Fof_atom (',' fof_param+=Fof_atom)* ')')?;
		@Override public ParserRule getRule() { return rule; }
		
		//name=(Lower_token_and_keyword | STRING) ('(' fof_param+=Fof_atom (',' fof_param+=Fof_atom)* ')')?
		public Group getGroup() { return cGroup; }
		
		//name=(Lower_token_and_keyword | STRING)
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//(Lower_token_and_keyword | STRING)
		public Alternatives getNameAlternatives_0_0() { return cNameAlternatives_0_0; }
		
		//Lower_token_and_keyword
		public RuleCall getNameLower_token_and_keywordParserRuleCall_0_0_0() { return cNameLower_token_and_keywordParserRuleCall_0_0_0; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_0_0_1() { return cNameSTRINGTerminalRuleCall_0_0_1; }
		
		//('(' fof_param+=Fof_atom (',' fof_param+=Fof_atom)* ')')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//fof_param+=Fof_atom
		public Assignment getFof_paramAssignment_1_1() { return cFof_paramAssignment_1_1; }
		
		//Fof_atom
		public RuleCall getFof_paramFof_atomParserRuleCall_1_1_0() { return cFof_paramFof_atomParserRuleCall_1_1_0; }
		
		//(',' fof_param+=Fof_atom)*
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//','
		public Keyword getCommaKeyword_1_2_0() { return cCommaKeyword_1_2_0; }
		
		//fof_param+=Fof_atom
		public Assignment getFof_paramAssignment_1_2_1() { return cFof_paramAssignment_1_2_1; }
		
		//Fof_atom
		public RuleCall getFof_paramFof_atomParserRuleCall_1_2_1_0() { return cFof_paramFof_atomParserRuleCall_1_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}
	public class Fof_varElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Fof_var");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameUPPER_TOKENTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Fof_var:
		//	name=UPPER_TOKEN;
		@Override public ParserRule getRule() { return rule; }
		
		//name=UPPER_TOKEN
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//UPPER_TOKEN
		public RuleCall getNameUPPER_TOKENTerminalRuleCall_0() { return cNameUPPER_TOKENTerminalRuleCall_0; }
	}
	public class Fof_quantifier_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Fof_quantifier_expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFof_quantifierAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cFof_quantifierAlternatives_0_0 = (Alternatives)cFof_quantifierAssignment_0.eContents().get(0);
		private final Keyword cFof_quantifierExclamationMarkKeyword_0_0_0 = (Keyword)cFof_quantifierAlternatives_0_0.eContents().get(0);
		private final Keyword cFof_quantifierQuestionMarkKeyword_0_0_1 = (Keyword)cFof_quantifierAlternatives_0_0.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cFof_paramAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFof_paramFof_variable_listParserRuleCall_2_0 = (RuleCall)cFof_paramAssignment_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cColonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cFof_expAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cFof_expFof_expressionParserRuleCall_5_0 = (RuleCall)cFof_expAssignment_5.eContents().get(0);
		
		//Fof_quantifier_expression Fof_expression:
		//	fof_quantifier=('!' // for all
		//	| '?' //there exists
		//) '[' fof_param=Fof_variable_list ']' ':' fof_exp=Fof_expression;
		@Override public ParserRule getRule() { return rule; }
		
		//fof_quantifier=('!' // for all
		//| '?' //there exists
		//) '[' fof_param=Fof_variable_list ']' ':' fof_exp=Fof_expression
		public Group getGroup() { return cGroup; }
		
		//fof_quantifier=('!' // for all
		//| '?' //there exists
		//)
		public Assignment getFof_quantifierAssignment_0() { return cFof_quantifierAssignment_0; }
		
		//('!' // for all
		//| '?' //there exists
		//)
		public Alternatives getFof_quantifierAlternatives_0_0() { return cFof_quantifierAlternatives_0_0; }
		
		//'!'
		public Keyword getFof_quantifierExclamationMarkKeyword_0_0_0() { return cFof_quantifierExclamationMarkKeyword_0_0_0; }
		
		//'?'
		public Keyword getFof_quantifierQuestionMarkKeyword_0_0_1() { return cFof_quantifierQuestionMarkKeyword_0_0_1; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }
		
		//fof_param=Fof_variable_list
		public Assignment getFof_paramAssignment_2() { return cFof_paramAssignment_2; }
		
		//Fof_variable_list
		public RuleCall getFof_paramFof_variable_listParserRuleCall_2_0() { return cFof_paramFof_variable_listParserRuleCall_2_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
		
		//':'
		public Keyword getColonKeyword_4() { return cColonKeyword_4; }
		
		//fof_exp=Fof_expression
		public Assignment getFof_expAssignment_5() { return cFof_expAssignment_5; }
		
		//Fof_expression
		public RuleCall getFof_expFof_expressionParserRuleCall_5_0() { return cFof_expFof_expressionParserRuleCall_5_0; }
	}
	public class Fof_variable_listElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Fof_variable_list");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cParamsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cParamsFof_varParserRuleCall_0_0 = (RuleCall)cParamsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cParamsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cParamsFof_varParserRuleCall_1_1_0 = (RuleCall)cParamsAssignment_1_1.eContents().get(0);
		
		//Fof_variable_list:
		//	params+=Fof_var (',' params+=Fof_var)*;
		@Override public ParserRule getRule() { return rule; }
		
		//params+=Fof_var (',' params+=Fof_var)*
		public Group getGroup() { return cGroup; }
		
		//params+=Fof_var
		public Assignment getParamsAssignment_0() { return cParamsAssignment_0; }
		
		//Fof_var
		public RuleCall getParamsFof_varParserRuleCall_0_0() { return cParamsFof_varParserRuleCall_0_0; }
		
		//(',' params+=Fof_var)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//params+=Fof_var
		public Assignment getParamsAssignment_1_1() { return cParamsAssignment_1_1; }
		
		//Fof_var
		public RuleCall getParamsFof_varParserRuleCall_1_1_0() { return cParamsFof_varParserRuleCall_1_1_0; }
	}
	public class Tff_inputElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Tff_input");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTff_rootParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIncludeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//////////////////////////////////////////////////////////////////////////////
		//// TFF
		//Tff_input:
		//	Tff_root | Include;
		@Override public ParserRule getRule() { return rule; }
		
		//Tff_root | Include
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Tff_root
		public RuleCall getTff_rootParserRuleCall_0() { return cTff_rootParserRuleCall_0; }
		
		//Include
		public RuleCall getIncludeParserRuleCall_1() { return cIncludeParserRuleCall_1; }
	}
	public class Tff_rootElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Tff_root");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cTffKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cNameAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final Alternatives cNameAlternatives_0_2_0 = (Alternatives)cNameAssignment_0_2.eContents().get(0);
		private final RuleCall cNameLower_token_and_keywordParserRuleCall_0_2_0_0 = (RuleCall)cNameAlternatives_0_2_0.eContents().get(0);
		private final RuleCall cNameSTRINGTerminalRuleCall_0_2_0_1 = (RuleCall)cNameAlternatives_0_2_0.eContents().get(1);
		private final Keyword cCommaKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final Assignment cFormula_roleAssignment_0_4 = (Assignment)cGroup_0.eContents().get(4);
		private final Alternatives cFormula_roleAlternatives_0_4_0 = (Alternatives)cFormula_roleAssignment_0_4.eContents().get(0);
		private final Keyword cFormula_roleAxiomKeyword_0_4_0_0 = (Keyword)cFormula_roleAlternatives_0_4_0.eContents().get(0);
		private final Keyword cFormula_roleHypothesisKeyword_0_4_0_1 = (Keyword)cFormula_roleAlternatives_0_4_0.eContents().get(1);
		private final Keyword cFormula_roleNegated_conjectureKeyword_0_4_0_2 = (Keyword)cFormula_roleAlternatives_0_4_0.eContents().get(2);
		private final Keyword cFormula_roleConjectureKeyword_0_4_0_3 = (Keyword)cFormula_roleAlternatives_0_4_0.eContents().get(3);
		private final Keyword cFormula_roleDefinitionKeyword_0_4_0_4 = (Keyword)cFormula_roleAlternatives_0_4_0.eContents().get(4);
		private final Keyword cFormula_roleLemmaKeyword_0_4_0_5 = (Keyword)cFormula_roleAlternatives_0_4_0.eContents().get(5);
		private final Keyword cCommaKeyword_0_5 = (Keyword)cGroup_0.eContents().get(5);
		private final Assignment cExpAssignment_0_6 = (Assignment)cGroup_0.eContents().get(6);
		private final RuleCall cExpTff_expressionParserRuleCall_0_6_0 = (RuleCall)cExpAssignment_0_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_7 = (Keyword)cGroup_0.eContents().get(7);
		private final Keyword cFullStopKeyword_0_8 = (Keyword)cGroup_0.eContents().get(8);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cTffKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cNameAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cNameAlternatives_1_2_0 = (Alternatives)cNameAssignment_1_2.eContents().get(0);
		private final RuleCall cNameLower_token_and_keywordParserRuleCall_1_2_0_0 = (RuleCall)cNameAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cNameSTRINGTerminalRuleCall_1_2_0_1 = (RuleCall)cNameAlternatives_1_2_0.eContents().get(1);
		private final Keyword cCommaKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cFormula_roleAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final Keyword cFormula_roleTypeKeyword_1_4_0 = (Keyword)cFormula_roleAssignment_1_4.eContents().get(0);
		private final Keyword cCommaKeyword_1_5 = (Keyword)cGroup_1.eContents().get(5);
		private final Assignment cDefAssignment_1_6 = (Assignment)cGroup_1.eContents().get(6);
		private final RuleCall cDefTff_formula_type_definitionParserRuleCall_1_6_0 = (RuleCall)cDefAssignment_1_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_7 = (Keyword)cGroup_1.eContents().get(7);
		private final Keyword cFullStopKeyword_1_8 = (Keyword)cGroup_1.eContents().get(8);
		
		//Tff_root:
		//	'tff' '(' name=(Lower_token_and_keyword | STRING)
		//	',' formula_role=('axiom' | 'hypothesis' | 'negated_conjecture' | 'conjecture' | 'definition' | 'lemma')
		//	',' exp=Tff_expression
		//	')' '.' | 'tff' '(' name=(Lower_token_and_keyword | STRING)
		//	',' formula_role='type' ',' def=Tff_formula_type_definition
		//	')' '.';
		@Override public ParserRule getRule() { return rule; }
		
		//'tff' '(' name=(Lower_token_and_keyword | STRING) ',' formula_role=('axiom' | 'hypothesis' | 'negated_conjecture' |
		//'conjecture' | 'definition' | 'lemma') ',' exp=Tff_expression ')' '.' | 'tff' '(' name=(Lower_token_and_keyword |
		//STRING) ',' formula_role='type' ',' def=Tff_formula_type_definition ')' '.'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'tff' '(' name=(Lower_token_and_keyword | STRING) ',' formula_role=('axiom' | 'hypothesis' | 'negated_conjecture' |
		//'conjecture' | 'definition' | 'lemma') ',' exp=Tff_expression ')' '.'
		public Group getGroup_0() { return cGroup_0; }
		
		//'tff'
		public Keyword getTffKeyword_0_0() { return cTffKeyword_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_1() { return cLeftParenthesisKeyword_0_1; }
		
		//name=(Lower_token_and_keyword | STRING)
		public Assignment getNameAssignment_0_2() { return cNameAssignment_0_2; }
		
		//(Lower_token_and_keyword | STRING)
		public Alternatives getNameAlternatives_0_2_0() { return cNameAlternatives_0_2_0; }
		
		//Lower_token_and_keyword
		public RuleCall getNameLower_token_and_keywordParserRuleCall_0_2_0_0() { return cNameLower_token_and_keywordParserRuleCall_0_2_0_0; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_0_2_0_1() { return cNameSTRINGTerminalRuleCall_0_2_0_1; }
		
		//','
		public Keyword getCommaKeyword_0_3() { return cCommaKeyword_0_3; }
		
		//formula_role=('axiom' | 'hypothesis' | 'negated_conjecture' | 'conjecture' | 'definition' | 'lemma')
		public Assignment getFormula_roleAssignment_0_4() { return cFormula_roleAssignment_0_4; }
		
		//('axiom' | 'hypothesis' | 'negated_conjecture' | 'conjecture' | 'definition' | 'lemma')
		public Alternatives getFormula_roleAlternatives_0_4_0() { return cFormula_roleAlternatives_0_4_0; }
		
		//'axiom'
		public Keyword getFormula_roleAxiomKeyword_0_4_0_0() { return cFormula_roleAxiomKeyword_0_4_0_0; }
		
		//'hypothesis'
		public Keyword getFormula_roleHypothesisKeyword_0_4_0_1() { return cFormula_roleHypothesisKeyword_0_4_0_1; }
		
		//'negated_conjecture'
		public Keyword getFormula_roleNegated_conjectureKeyword_0_4_0_2() { return cFormula_roleNegated_conjectureKeyword_0_4_0_2; }
		
		//'conjecture'
		public Keyword getFormula_roleConjectureKeyword_0_4_0_3() { return cFormula_roleConjectureKeyword_0_4_0_3; }
		
		//'definition'
		public Keyword getFormula_roleDefinitionKeyword_0_4_0_4() { return cFormula_roleDefinitionKeyword_0_4_0_4; }
		
		//'lemma'
		public Keyword getFormula_roleLemmaKeyword_0_4_0_5() { return cFormula_roleLemmaKeyword_0_4_0_5; }
		
		//','
		public Keyword getCommaKeyword_0_5() { return cCommaKeyword_0_5; }
		
		//exp=Tff_expression
		public Assignment getExpAssignment_0_6() { return cExpAssignment_0_6; }
		
		//Tff_expression
		public RuleCall getExpTff_expressionParserRuleCall_0_6_0() { return cExpTff_expressionParserRuleCall_0_6_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_7() { return cRightParenthesisKeyword_0_7; }
		
		//'.'
		public Keyword getFullStopKeyword_0_8() { return cFullStopKeyword_0_8; }
		
		//'tff' '(' name=(Lower_token_and_keyword | STRING) ',' formula_role='type' ',' def=Tff_formula_type_definition ')' '.'
		public Group getGroup_1() { return cGroup_1; }
		
		//'tff'
		public Keyword getTffKeyword_1_0() { return cTffKeyword_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }
		
		//name=(Lower_token_and_keyword | STRING)
		public Assignment getNameAssignment_1_2() { return cNameAssignment_1_2; }
		
		//(Lower_token_and_keyword | STRING)
		public Alternatives getNameAlternatives_1_2_0() { return cNameAlternatives_1_2_0; }
		
		//Lower_token_and_keyword
		public RuleCall getNameLower_token_and_keywordParserRuleCall_1_2_0_0() { return cNameLower_token_and_keywordParserRuleCall_1_2_0_0; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_1_2_0_1() { return cNameSTRINGTerminalRuleCall_1_2_0_1; }
		
		//','
		public Keyword getCommaKeyword_1_3() { return cCommaKeyword_1_3; }
		
		//formula_role='type'
		public Assignment getFormula_roleAssignment_1_4() { return cFormula_roleAssignment_1_4; }
		
		//'type'
		public Keyword getFormula_roleTypeKeyword_1_4_0() { return cFormula_roleTypeKeyword_1_4_0; }
		
		//','
		public Keyword getCommaKeyword_1_5() { return cCommaKeyword_1_5; }
		
		//def=Tff_formula_type_definition
		public Assignment getDefAssignment_1_6() { return cDefAssignment_1_6; }
		
		//Tff_formula_type_definition
		public RuleCall getDefTff_formula_type_definitionParserRuleCall_1_6_0() { return cDefTff_formula_type_definitionParserRuleCall_1_6_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_7() { return cRightParenthesisKeyword_1_7; }
		
		//'.'
		public Keyword getFullStopKeyword_1_8() { return cFullStopKeyword_1_8; }
	}
	public class Tff_formula_type_definitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Tff_formula_type_definition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cTff_formula_type_definitionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Assignment cNameAssignment_1_0_0 = (Assignment)cAlternatives_1_0.eContents().get(0);
		private final RuleCall cNameLower_token_and_keywordParserRuleCall_1_0_0_0 = (RuleCall)cNameAssignment_1_0_0.eContents().get(0);
		private final Assignment cNameAssignment_1_0_1 = (Assignment)cAlternatives_1_0.eContents().get(1);
		private final RuleCall cNameSTRINGTerminalRuleCall_1_0_1_0 = (RuleCall)cNameAssignment_1_0_1.eContents().get(0);
		private final Keyword cColonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cExpAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cExpAlternatives_1_2_0 = (Alternatives)cExpAssignment_1_2.eContents().get(0);
		private final RuleCall cExpTff_type_quantifier_epressionParserRuleCall_1_2_0_0 = (RuleCall)cExpAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cExpTff_type_expressionParserRuleCall_1_2_0_1 = (RuleCall)cExpAlternatives_1_2_0.eContents().get(1);
		
		//Tff_formula_type_definition:
		//	'(' Tff_formula_type_definition ')' | (name=Lower_token_and_keyword | name=STRING) ':'
		//	exp=(Tff_type_quantifier_epression | Tff_type_expression);
		@Override public ParserRule getRule() { return rule; }
		
		//'(' Tff_formula_type_definition ')' | (name=Lower_token_and_keyword | name=STRING) ':'
		//exp=(Tff_type_quantifier_epression | Tff_type_expression)
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' Tff_formula_type_definition ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//Tff_formula_type_definition
		public RuleCall getTff_formula_type_definitionParserRuleCall_0_1() { return cTff_formula_type_definitionParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//(name=Lower_token_and_keyword | name=STRING) ':' exp=(Tff_type_quantifier_epression | Tff_type_expression)
		public Group getGroup_1() { return cGroup_1; }
		
		//name=Lower_token_and_keyword | name=STRING
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//name=Lower_token_and_keyword
		public Assignment getNameAssignment_1_0_0() { return cNameAssignment_1_0_0; }
		
		//Lower_token_and_keyword
		public RuleCall getNameLower_token_and_keywordParserRuleCall_1_0_0_0() { return cNameLower_token_and_keywordParserRuleCall_1_0_0_0; }
		
		//name=STRING
		public Assignment getNameAssignment_1_0_1() { return cNameAssignment_1_0_1; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_1_0_1_0() { return cNameSTRINGTerminalRuleCall_1_0_1_0; }
		
		//':'
		public Keyword getColonKeyword_1_1() { return cColonKeyword_1_1; }
		
		//exp=(Tff_type_quantifier_epression | Tff_type_expression)
		public Assignment getExpAssignment_1_2() { return cExpAssignment_1_2; }
		
		//(Tff_type_quantifier_epression | Tff_type_expression)
		public Alternatives getExpAlternatives_1_2_0() { return cExpAlternatives_1_2_0; }
		
		//Tff_type_quantifier_epression
		public RuleCall getExpTff_type_quantifier_epressionParserRuleCall_1_2_0_0() { return cExpTff_type_quantifier_epressionParserRuleCall_1_2_0_0; }
		
		//Tff_type_expression
		public RuleCall getExpTff_type_expressionParserRuleCall_1_2_0_1() { return cExpTff_type_expressionParserRuleCall_1_2_0_1; }
	}
	public class Tff_type_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Tff_type_expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTff_terminal_type_expressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOperLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpGreaterThanSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpAsteriskKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightTff_terminal_type_expressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		////these operators are left associative, as god intended
		////TODO: should we AST modle these as Tff_type_constant with 2 params?
		//Tff_type_expression:
		//	Tff_terminal_type_expression ({oper.left=current} op=('>' | '*') right+=Tff_terminal_type_expression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Tff_terminal_type_expression ({oper.left=current} op=('>' | '*') right+=Tff_terminal_type_expression)*
		public Group getGroup() { return cGroup; }
		
		//Tff_terminal_type_expression
		public RuleCall getTff_terminal_type_expressionParserRuleCall_0() { return cTff_terminal_type_expressionParserRuleCall_0; }
		
		//({oper.left=current} op=('>' | '*') right+=Tff_terminal_type_expression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{oper.left=current}
		public Action getOperLeftAction_1_0() { return cOperLeftAction_1_0; }
		
		//op=('>' | '*')
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//('>' | '*')
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }
		
		//'>'
		public Keyword getOpGreaterThanSignKeyword_1_1_0_0() { return cOpGreaterThanSignKeyword_1_1_0_0; }
		
		//'*'
		public Keyword getOpAsteriskKeyword_1_1_0_1() { return cOpAsteriskKeyword_1_1_0_1; }
		
		//right+=Tff_terminal_type_expression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Tff_terminal_type_expression
		public RuleCall getRightTff_terminal_type_expressionParserRuleCall_1_2_0() { return cRightTff_terminal_type_expressionParserRuleCall_1_2_0; }
	}
	public class Tff_terminal_type_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Tff_terminal_type_expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTff_type_atomParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cTff_type_expressionParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//Tff_terminal_type_expression Tff_type_expression:
		//	Tff_type_atom | '(' Tff_type_expression ')';
		@Override public ParserRule getRule() { return rule; }
		
		//Tff_type_atom | '(' Tff_type_expression ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Tff_type_atom
		public RuleCall getTff_type_atomParserRuleCall_0() { return cTff_type_atomParserRuleCall_0; }
		
		//'(' Tff_type_expression ')'
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//Tff_type_expression
		public RuleCall getTff_type_expressionParserRuleCall_1_1() { return cTff_type_expressionParserRuleCall_1_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}
	public class Tff_type_atomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Tff_type_atom");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTff_type_constantParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTff_varParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cTff_type_literalParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Tff_type_atom:
		//	Tff_type_constant | Tff_var | Tff_type_literal;
		@Override public ParserRule getRule() { return rule; }
		
		//Tff_type_constant | Tff_var | Tff_type_literal
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Tff_type_constant
		public RuleCall getTff_type_constantParserRuleCall_0() { return cTff_type_constantParserRuleCall_0; }
		
		//Tff_var
		public RuleCall getTff_varParserRuleCall_1() { return cTff_varParserRuleCall_1; }
		
		//Tff_type_literal
		public RuleCall getTff_type_literalParserRuleCall_2() { return cTff_type_literalParserRuleCall_2; }
	}
	public class Tff_type_constantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Tff_type_constant");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cNameAlternatives_0_0 = (Alternatives)cNameAssignment_0.eContents().get(0);
		private final RuleCall cNameLower_token_and_keywordParserRuleCall_0_0_0 = (RuleCall)cNameAlternatives_0_0.eContents().get(0);
		private final RuleCall cNameSTRINGTerminalRuleCall_0_0_1 = (RuleCall)cNameAlternatives_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cParamAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cParamTff_type_atomParserRuleCall_1_1_0 = (RuleCall)cParamAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cCommaKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cParamAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cParamTff_type_atomParserRuleCall_1_2_1_0 = (RuleCall)cParamAssignment_1_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//Tff_type_constant:
		//	name=(Lower_token_and_keyword | STRING) ('(' param+=Tff_type_atom (',' param+=Tff_type_atom)* ')')?;
		@Override public ParserRule getRule() { return rule; }
		
		//name=(Lower_token_and_keyword | STRING) ('(' param+=Tff_type_atom (',' param+=Tff_type_atom)* ')')?
		public Group getGroup() { return cGroup; }
		
		//name=(Lower_token_and_keyword | STRING)
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//(Lower_token_and_keyword | STRING)
		public Alternatives getNameAlternatives_0_0() { return cNameAlternatives_0_0; }
		
		//Lower_token_and_keyword
		public RuleCall getNameLower_token_and_keywordParserRuleCall_0_0_0() { return cNameLower_token_and_keywordParserRuleCall_0_0_0; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_0_0_1() { return cNameSTRINGTerminalRuleCall_0_0_1; }
		
		//('(' param+=Tff_type_atom (',' param+=Tff_type_atom)* ')')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//param+=Tff_type_atom
		public Assignment getParamAssignment_1_1() { return cParamAssignment_1_1; }
		
		//Tff_type_atom
		public RuleCall getParamTff_type_atomParserRuleCall_1_1_0() { return cParamTff_type_atomParserRuleCall_1_1_0; }
		
		//(',' param+=Tff_type_atom)*
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//','
		public Keyword getCommaKeyword_1_2_0() { return cCommaKeyword_1_2_0; }
		
		//param+=Tff_type_atom
		public Assignment getParamAssignment_1_2_1() { return cParamAssignment_1_2_1; }
		
		//Tff_type_atom
		public RuleCall getParamTff_type_atomParserRuleCall_1_2_1_0() { return cParamTff_type_atomParserRuleCall_1_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}
	public class Tff_type_literalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Tff_type_literal");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cNameAlternatives_0 = (Alternatives)cNameAssignment.eContents().get(0);
		private final Keyword cNameIKeyword_0_0 = (Keyword)cNameAlternatives_0.eContents().get(0);
		private final Keyword cNameOKeyword_0_1 = (Keyword)cNameAlternatives_0.eContents().get(1);
		private final Keyword cNameTTypeKeyword_0_2 = (Keyword)cNameAlternatives_0.eContents().get(2);
		private final Keyword cNameIntKeyword_0_3 = (Keyword)cNameAlternatives_0.eContents().get(3);
		private final Keyword cNameRealKeyword_0_4 = (Keyword)cNameAlternatives_0.eContents().get(4);
		private final Keyword cNameRatKeyword_0_5 = (Keyword)cNameAlternatives_0.eContents().get(5);
		
		////TODO: don't support edgecase:
		////tff(sorted_type,type,(
		////    sorted: "$i" )).
		//Tff_type_literal Tff_type_constant:
		//	name=('$i' | '$o' | '$tType' | '$int' | '$real' | '$rat');
		@Override public ParserRule getRule() { return rule; }
		
		//name=('$i' | '$o' | '$tType' | '$int' | '$real' | '$rat')
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//('$i' | '$o' | '$tType' | '$int' | '$real' | '$rat')
		public Alternatives getNameAlternatives_0() { return cNameAlternatives_0; }
		
		//'$i'
		public Keyword getNameIKeyword_0_0() { return cNameIKeyword_0_0; }
		
		//'$o'
		public Keyword getNameOKeyword_0_1() { return cNameOKeyword_0_1; }
		
		//'$tType'
		public Keyword getNameTTypeKeyword_0_2() { return cNameTTypeKeyword_0_2; }
		
		//'$int'
		public Keyword getNameIntKeyword_0_3() { return cNameIntKeyword_0_3; }
		
		//'$real'
		public Keyword getNameRealKeyword_0_4() { return cNameRealKeyword_0_4; }
		
		//'$rat'
		public Keyword getNameRatKeyword_0_5() { return cNameRatKeyword_0_5; }
	}
	public class Tff_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Tff_expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTff_terminating_expressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpBinary_operatorParserRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightTff_terminating_expressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Tff_expression:
		//	Tff_terminating_expression ({binary.left=current} op=Binary_operator right=Tff_terminating_expression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Tff_terminating_expression ({binary.left=current} op=Binary_operator right=Tff_terminating_expression)*
		public Group getGroup() { return cGroup; }
		
		//Tff_terminating_expression
		public RuleCall getTff_terminating_expressionParserRuleCall_0() { return cTff_terminating_expressionParserRuleCall_0; }
		
		//({binary.left=current} op=Binary_operator right=Tff_terminating_expression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{binary.left=current}
		public Action getBinaryLeftAction_1_0() { return cBinaryLeftAction_1_0; }
		
		//op=Binary_operator
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//Binary_operator
		public RuleCall getOpBinary_operatorParserRuleCall_1_1_0() { return cOpBinary_operatorParserRuleCall_1_1_0; }
		
		//right=Tff_terminating_expression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Tff_terminating_expression
		public RuleCall getRightTff_terminating_expressionParserRuleCall_1_2_0() { return cRightTff_terminating_expressionParserRuleCall_1_2_0; }
	}
	public class Tff_terminating_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Tff_terminating_expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cAtomAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cAtomTff_atomParserRuleCall_0_0 = (RuleCall)cAtomAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cTff_expressionParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Assignment cNegationAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final Keyword cNegationTildeKeyword_2_0_0 = (Keyword)cNegationAssignment_2_0.eContents().get(0);
		private final Assignment cExpAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cExpTff_expressionParserRuleCall_2_1_0 = (RuleCall)cExpAssignment_2_1.eContents().get(0);
		private final Assignment cExpAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cExpTff_quantifier_expressionParserRuleCall_3_0 = (RuleCall)cExpAssignment_3.eContents().get(0);
		
		//Tff_terminating_expression Tff_expression:
		//	atom=Tff_atom |
		//	'(' Tff_expression ')' | negation?='~' exp=Tff_expression | exp=Tff_quantifier_expression;
		@Override public ParserRule getRule() { return rule; }
		
		//atom=Tff_atom | '(' Tff_expression ')' | negation?='~' exp=Tff_expression | exp=Tff_quantifier_expression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//atom=Tff_atom
		public Assignment getAtomAssignment_0() { return cAtomAssignment_0; }
		
		//Tff_atom
		public RuleCall getAtomTff_atomParserRuleCall_0_0() { return cAtomTff_atomParserRuleCall_0_0; }
		
		//'(' Tff_expression ')'
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//Tff_expression
		public RuleCall getTff_expressionParserRuleCall_1_1() { return cTff_expressionParserRuleCall_1_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
		
		//negation?='~' exp=Tff_expression
		public Group getGroup_2() { return cGroup_2; }
		
		//negation?='~'
		public Assignment getNegationAssignment_2_0() { return cNegationAssignment_2_0; }
		
		//'~'
		public Keyword getNegationTildeKeyword_2_0_0() { return cNegationTildeKeyword_2_0_0; }
		
		//exp=Tff_expression
		public Assignment getExpAssignment_2_1() { return cExpAssignment_2_1; }
		
		//Tff_expression
		public RuleCall getExpTff_expressionParserRuleCall_2_1_0() { return cExpTff_expressionParserRuleCall_2_1_0; }
		
		//exp=Tff_quantifier_expression
		public Assignment getExpAssignment_3() { return cExpAssignment_3; }
		
		//Tff_quantifier_expression
		public RuleCall getExpTff_quantifier_expressionParserRuleCall_3_0() { return cExpTff_quantifier_expressionParserRuleCall_3_0; }
	}
	public class Tff_atomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Tff_atom");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTff_varParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTff_atom_literalParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cTff_constantParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cTff_predefined_function_1_argsParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cTff_predefined_function_2_argsParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//Tff_atom:
		//	Tff_var | Tff_atom_literal | Tff_constant | Tff_predefined_function_1_args | Tff_predefined_function_2_args;
		@Override public ParserRule getRule() { return rule; }
		
		//Tff_var | Tff_atom_literal | Tff_constant | Tff_predefined_function_1_args | Tff_predefined_function_2_args
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Tff_var
		public RuleCall getTff_varParserRuleCall_0() { return cTff_varParserRuleCall_0; }
		
		//Tff_atom_literal
		public RuleCall getTff_atom_literalParserRuleCall_1() { return cTff_atom_literalParserRuleCall_1; }
		
		//Tff_constant
		public RuleCall getTff_constantParserRuleCall_2() { return cTff_constantParserRuleCall_2; }
		
		//Tff_predefined_function_1_args
		public RuleCall getTff_predefined_function_1_argsParserRuleCall_3() { return cTff_predefined_function_1_argsParserRuleCall_3; }
		
		//Tff_predefined_function_2_args
		public RuleCall getTff_predefined_function_2_argsParserRuleCall_4() { return cTff_predefined_function_2_argsParserRuleCall_4; }
	}
	public class Tff_constantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Tff_constant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cNameAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final Alternatives cNameAlternatives_0_0_0 = (Alternatives)cNameAssignment_0_0.eContents().get(0);
		private final RuleCall cNameLower_token_and_keywordParserRuleCall_0_0_0_0 = (RuleCall)cNameAlternatives_0_0_0.eContents().get(0);
		private final RuleCall cNameSTRINGTerminalRuleCall_0_0_0_1 = (RuleCall)cNameAlternatives_0_0_0.eContents().get(1);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final Assignment cParamAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cParamTff_atomParserRuleCall_0_1_1_0 = (RuleCall)cParamAssignment_0_1_1.eContents().get(0);
		private final Group cGroup_0_1_2 = (Group)cGroup_0_1.eContents().get(2);
		private final Keyword cCommaKeyword_0_1_2_0 = (Keyword)cGroup_0_1_2.eContents().get(0);
		private final Assignment cParamAssignment_0_1_2_1 = (Assignment)cGroup_0_1_2.eContents().get(1);
		private final RuleCall cParamTff_atomParserRuleCall_0_1_2_1_0 = (RuleCall)cParamAssignment_0_1_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_1_3 = (Keyword)cGroup_0_1.eContents().get(3);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cTopAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cTopLower_token_and_keywordParserRuleCall_1_0_0 = (RuleCall)cTopAssignment_1_0.eContents().get(0);
		private final Assignment cNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cNameSolidusKeyword_1_1_0 = (Keyword)cNameAssignment_1_1.eContents().get(0);
		private final Assignment cBottomAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cBottomLower_token_and_keywordParserRuleCall_1_2_0 = (RuleCall)cBottomAssignment_1_2.eContents().get(0);
		
		//Tff_constant:
		//	name=(Lower_token_and_keyword | STRING) ('(' param+=Tff_atom (',' param+=Tff_atom)* ')')? |
		//	top=Lower_token_and_keyword name='/' bottom=Lower_token_and_keyword;
		@Override public ParserRule getRule() { return rule; }
		
		//name=(Lower_token_and_keyword | STRING) ('(' param+=Tff_atom (',' param+=Tff_atom)* ')')? | top=Lower_token_and_keyword
		//name='/' bottom=Lower_token_and_keyword
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//name=(Lower_token_and_keyword | STRING) ('(' param+=Tff_atom (',' param+=Tff_atom)* ')')?
		public Group getGroup_0() { return cGroup_0; }
		
		//name=(Lower_token_and_keyword | STRING)
		public Assignment getNameAssignment_0_0() { return cNameAssignment_0_0; }
		
		//(Lower_token_and_keyword | STRING)
		public Alternatives getNameAlternatives_0_0_0() { return cNameAlternatives_0_0_0; }
		
		//Lower_token_and_keyword
		public RuleCall getNameLower_token_and_keywordParserRuleCall_0_0_0_0() { return cNameLower_token_and_keywordParserRuleCall_0_0_0_0; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_0_0_0_1() { return cNameSTRINGTerminalRuleCall_0_0_0_1; }
		
		//('(' param+=Tff_atom (',' param+=Tff_atom)* ')')?
		public Group getGroup_0_1() { return cGroup_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_1_0() { return cLeftParenthesisKeyword_0_1_0; }
		
		//param+=Tff_atom
		public Assignment getParamAssignment_0_1_1() { return cParamAssignment_0_1_1; }
		
		//Tff_atom
		public RuleCall getParamTff_atomParserRuleCall_0_1_1_0() { return cParamTff_atomParserRuleCall_0_1_1_0; }
		
		//(',' param+=Tff_atom)*
		public Group getGroup_0_1_2() { return cGroup_0_1_2; }
		
		//','
		public Keyword getCommaKeyword_0_1_2_0() { return cCommaKeyword_0_1_2_0; }
		
		//param+=Tff_atom
		public Assignment getParamAssignment_0_1_2_1() { return cParamAssignment_0_1_2_1; }
		
		//Tff_atom
		public RuleCall getParamTff_atomParserRuleCall_0_1_2_1_0() { return cParamTff_atomParserRuleCall_0_1_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_1_3() { return cRightParenthesisKeyword_0_1_3; }
		
		//top=Lower_token_and_keyword name='/' bottom=Lower_token_and_keyword
		public Group getGroup_1() { return cGroup_1; }
		
		//top=Lower_token_and_keyword
		public Assignment getTopAssignment_1_0() { return cTopAssignment_1_0; }
		
		//Lower_token_and_keyword
		public RuleCall getTopLower_token_and_keywordParserRuleCall_1_0_0() { return cTopLower_token_and_keywordParserRuleCall_1_0_0; }
		
		//name='/'
		public Assignment getNameAssignment_1_1() { return cNameAssignment_1_1; }
		
		//'/'
		public Keyword getNameSolidusKeyword_1_1_0() { return cNameSolidusKeyword_1_1_0; }
		
		//bottom=Lower_token_and_keyword
		public Assignment getBottomAssignment_1_2() { return cBottomAssignment_1_2; }
		
		//Lower_token_and_keyword
		public RuleCall getBottomLower_token_and_keywordParserRuleCall_1_2_0() { return cBottomLower_token_and_keywordParserRuleCall_1_2_0; }
	}
	public class Tff_atom_literalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Tff_atom_literal");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cNameAlternatives_0 = (Alternatives)cNameAssignment.eContents().get(0);
		private final Keyword cNameTrueKeyword_0_0 = (Keyword)cNameAlternatives_0.eContents().get(0);
		private final Keyword cNameFalseKeyword_0_1 = (Keyword)cNameAlternatives_0.eContents().get(1);
		
		//Tff_atom_literal Tff_constant:
		//	name=('$true' |
		//	'$false');
		@Override public ParserRule getRule() { return rule; }
		
		//name=('$true' | '$false')
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//('$true' | '$false')
		public Alternatives getNameAlternatives_0() { return cNameAlternatives_0; }
		
		//'$true'
		public Keyword getNameTrueKeyword_0_0() { return cNameTrueKeyword_0_0; }
		
		//'$false'
		public Keyword getNameFalseKeyword_0_1() { return cNameFalseKeyword_0_1; }
	}
	public class Tff_predefined_function_1_argsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Tff_predefined_function_1_args");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cNameAlternatives_0_0 = (Alternatives)cNameAssignment_0.eContents().get(0);
		private final Keyword cNameIs_intKeyword_0_0_0 = (Keyword)cNameAlternatives_0_0.eContents().get(0);
		private final Keyword cNameIs_ratKeyword_0_0_1 = (Keyword)cNameAlternatives_0_0.eContents().get(1);
		private final Keyword cNameUminusKeyword_0_0_2 = (Keyword)cNameAlternatives_0_0.eContents().get(2);
		private final Keyword cNameTo_intKeyword_0_0_3 = (Keyword)cNameAlternatives_0_0.eContents().get(3);
		private final Keyword cNameTo_ratKeyword_0_0_4 = (Keyword)cNameAlternatives_0_0.eContents().get(4);
		private final Keyword cNameTo_realKeyword_0_0_5 = (Keyword)cNameAlternatives_0_0.eContents().get(5);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParamAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParamTff_expressionParserRuleCall_2_0 = (RuleCall)cParamAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Tff_predefined_function_1_args Tff_constant:
		//	name=('$is_int' | '$is_rat' //ANYTHING -> BOOL
		//	| '$uminus' // NUM -> NUM ?
		//	| '$to_int' //ANYTHING? -> INT
		//	| '$to_rat' //ANYTHING? -> RAT
		//	| '$to_real' //ANYTHING? -> REAL
		//)
		//	'(' param+=Tff_expression ')';
		@Override public ParserRule getRule() { return rule; }
		
		//name=('$is_int' | '$is_rat' //ANYTHING -> BOOL
		//| '$uminus' // NUM -> NUM ?
		//| '$to_int' //ANYTHING? -> INT
		//| '$to_rat' //ANYTHING? -> RAT
		//| '$to_real' //ANYTHING? -> REAL
		//) '(' param+=Tff_expression ')'
		public Group getGroup() { return cGroup; }
		
		//name=('$is_int' | '$is_rat' //ANYTHING -> BOOL
		//| '$uminus' // NUM -> NUM ?
		//| '$to_int' //ANYTHING? -> INT
		//| '$to_rat' //ANYTHING? -> RAT
		//| '$to_real' //ANYTHING? -> REAL
		//)
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//('$is_int' | '$is_rat' //ANYTHING -> BOOL
		//| '$uminus' // NUM -> NUM ?
		//| '$to_int' //ANYTHING? -> INT
		//| '$to_rat' //ANYTHING? -> RAT
		//| '$to_real' //ANYTHING? -> REAL
		//)
		public Alternatives getNameAlternatives_0_0() { return cNameAlternatives_0_0; }
		
		//'$is_int'
		public Keyword getNameIs_intKeyword_0_0_0() { return cNameIs_intKeyword_0_0_0; }
		
		//'$is_rat'
		public Keyword getNameIs_ratKeyword_0_0_1() { return cNameIs_ratKeyword_0_0_1; }
		
		//'$uminus'
		public Keyword getNameUminusKeyword_0_0_2() { return cNameUminusKeyword_0_0_2; }
		
		//'$to_int'
		public Keyword getNameTo_intKeyword_0_0_3() { return cNameTo_intKeyword_0_0_3; }
		
		//'$to_rat'
		public Keyword getNameTo_ratKeyword_0_0_4() { return cNameTo_ratKeyword_0_0_4; }
		
		//'$to_real'
		public Keyword getNameTo_realKeyword_0_0_5() { return cNameTo_realKeyword_0_0_5; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//param+=Tff_expression
		public Assignment getParamAssignment_2() { return cParamAssignment_2; }
		
		//Tff_expression
		public RuleCall getParamTff_expressionParserRuleCall_2_0() { return cParamTff_expressionParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class Tff_predefined_function_2_argsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Tff_predefined_function_2_args");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFuncAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cFuncAlternatives_0_0 = (Alternatives)cFuncAssignment_0.eContents().get(0);
		private final Keyword cFuncLessKeyword_0_0_0 = (Keyword)cFuncAlternatives_0_0.eContents().get(0);
		private final Keyword cFuncSumKeyword_0_0_1 = (Keyword)cFuncAlternatives_0_0.eContents().get(1);
		private final Keyword cFuncDifferenceKeyword_0_0_2 = (Keyword)cFuncAlternatives_0_0.eContents().get(2);
		private final Keyword cFuncProductKeyword_0_0_3 = (Keyword)cFuncAlternatives_0_0.eContents().get(3);
		private final Keyword cFuncQuotientKeyword_0_0_4 = (Keyword)cFuncAlternatives_0_0.eContents().get(4);
		private final Keyword cFuncQuotient_eKeyword_0_0_5 = (Keyword)cFuncAlternatives_0_0.eContents().get(5);
		private final Keyword cFuncQuotient_tKeyword_0_0_6 = (Keyword)cFuncAlternatives_0_0.eContents().get(6);
		private final Keyword cFuncQuotient_fKeyword_0_0_7 = (Keyword)cFuncAlternatives_0_0.eContents().get(7);
		private final Keyword cFuncRemainder_eKeyword_0_0_8 = (Keyword)cFuncAlternatives_0_0.eContents().get(8);
		private final Keyword cFuncRemainder_tKeyword_0_0_9 = (Keyword)cFuncAlternatives_0_0.eContents().get(9);
		private final Keyword cFuncRemainder_fKeyword_0_0_10 = (Keyword)cFuncAlternatives_0_0.eContents().get(10);
		private final Keyword cFuncGreatereqKeyword_0_0_11 = (Keyword)cFuncAlternatives_0_0.eContents().get(11);
		private final Keyword cFuncLesseqKeyword_0_0_12 = (Keyword)cFuncAlternatives_0_0.eContents().get(12);
		private final Keyword cFuncGreaterKeyword_0_0_13 = (Keyword)cFuncAlternatives_0_0.eContents().get(13);
		private final Keyword cFuncEqKeyword_0_0_14 = (Keyword)cFuncAlternatives_0_0.eContents().get(14);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParamAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParamTff_expressionParserRuleCall_2_0 = (RuleCall)cParamAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cParamAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cParamTff_expressionParserRuleCall_4_0 = (RuleCall)cParamAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		////TODO: make this returns Tff_constant:
		////TODO: change func to name
		////TODO: possibly file a bug
		//Tff_predefined_function_2_args:
		//	func=('$less' | '$sum' | '$difference' | '$product' | '$quotient' | '$quotient_e' | '$quotient_t' | '$quotient_f' |
		//	'$remainder_e' | '$remainder_t' | '$remainder_f' | '$greatereq' | '$lesseq' | '$greater' | '$eq'
		//	//also $distinct
		//) '(' param+=Tff_expression ',' param+=Tff_expression ')';
		@Override public ParserRule getRule() { return rule; }
		
		////; returns Tff_constant:
		//func=('$less' | '$sum' | '$difference' | '$product' | '$quotient' | '$quotient_e' | '$quotient_t' | '$quotient_f' |
		//'$remainder_e' | '$remainder_t' | '$remainder_f' | '$greatereq' | '$lesseq' | '$greater' | '$eq' //also $distinct
		//) '(' param+=Tff_expression ',' param+=Tff_expression ')'
		public Group getGroup() { return cGroup; }
		
		////; returns Tff_constant:
		//func=('$less' | '$sum' | '$difference' | '$product' | '$quotient' | '$quotient_e' | '$quotient_t' | '$quotient_f' |
		//'$remainder_e' | '$remainder_t' | '$remainder_f' | '$greatereq' | '$lesseq' | '$greater' | '$eq' //also $distinct
		//)
		public Assignment getFuncAssignment_0() { return cFuncAssignment_0; }
		
		//('$less' | '$sum' | '$difference' | '$product' | '$quotient' | '$quotient_e' | '$quotient_t' | '$quotient_f' |
		//'$remainder_e' | '$remainder_t' | '$remainder_f' | '$greatereq' | '$lesseq' | '$greater' | '$eq' //also $distinct
		//)
		public Alternatives getFuncAlternatives_0_0() { return cFuncAlternatives_0_0; }
		
		//'$less'
		public Keyword getFuncLessKeyword_0_0_0() { return cFuncLessKeyword_0_0_0; }
		
		//'$sum'
		public Keyword getFuncSumKeyword_0_0_1() { return cFuncSumKeyword_0_0_1; }
		
		//'$difference'
		public Keyword getFuncDifferenceKeyword_0_0_2() { return cFuncDifferenceKeyword_0_0_2; }
		
		//'$product'
		public Keyword getFuncProductKeyword_0_0_3() { return cFuncProductKeyword_0_0_3; }
		
		//'$quotient'
		public Keyword getFuncQuotientKeyword_0_0_4() { return cFuncQuotientKeyword_0_0_4; }
		
		//'$quotient_e'
		public Keyword getFuncQuotient_eKeyword_0_0_5() { return cFuncQuotient_eKeyword_0_0_5; }
		
		//'$quotient_t'
		public Keyword getFuncQuotient_tKeyword_0_0_6() { return cFuncQuotient_tKeyword_0_0_6; }
		
		//'$quotient_f'
		public Keyword getFuncQuotient_fKeyword_0_0_7() { return cFuncQuotient_fKeyword_0_0_7; }
		
		//'$remainder_e'
		public Keyword getFuncRemainder_eKeyword_0_0_8() { return cFuncRemainder_eKeyword_0_0_8; }
		
		//'$remainder_t'
		public Keyword getFuncRemainder_tKeyword_0_0_9() { return cFuncRemainder_tKeyword_0_0_9; }
		
		//'$remainder_f'
		public Keyword getFuncRemainder_fKeyword_0_0_10() { return cFuncRemainder_fKeyword_0_0_10; }
		
		//'$greatereq'
		public Keyword getFuncGreatereqKeyword_0_0_11() { return cFuncGreatereqKeyword_0_0_11; }
		
		//'$lesseq'
		public Keyword getFuncLesseqKeyword_0_0_12() { return cFuncLesseqKeyword_0_0_12; }
		
		//'$greater'
		public Keyword getFuncGreaterKeyword_0_0_13() { return cFuncGreaterKeyword_0_0_13; }
		
		//'$eq'
		public Keyword getFuncEqKeyword_0_0_14() { return cFuncEqKeyword_0_0_14; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//param+=Tff_expression
		public Assignment getParamAssignment_2() { return cParamAssignment_2; }
		
		//Tff_expression
		public RuleCall getParamTff_expressionParserRuleCall_2_0() { return cParamTff_expressionParserRuleCall_2_0; }
		
		//','
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//param+=Tff_expression
		public Assignment getParamAssignment_4() { return cParamAssignment_4; }
		
		//Tff_expression
		public RuleCall getParamTff_expressionParserRuleCall_4_0() { return cParamTff_expressionParserRuleCall_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class Tff_varElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Tff_var");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameUPPER_TOKENTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Tff_var:
		//	name=UPPER_TOKEN;
		@Override public ParserRule getRule() { return rule; }
		
		//name=UPPER_TOKEN
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//UPPER_TOKEN
		public RuleCall getNameUPPER_TOKENTerminalRuleCall_0() { return cNameUPPER_TOKENTerminalRuleCall_0; }
	}
	public class Tff_var_declarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Tff_var_declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarTff_varParserRuleCall_0_0 = (RuleCall)cVarAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cVartypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVartypeTff_type_expressionParserRuleCall_2_0 = (RuleCall)cVartypeAssignment_2.eContents().get(0);
		
		//Tff_var_declaration:
		//	var=Tff_var ':' vartype=Tff_type_expression;
		@Override public ParserRule getRule() { return rule; }
		
		//var=Tff_var ':' vartype=Tff_type_expression
		public Group getGroup() { return cGroup; }
		
		//var=Tff_var
		public Assignment getVarAssignment_0() { return cVarAssignment_0; }
		
		//Tff_var
		public RuleCall getVarTff_varParserRuleCall_0_0() { return cVarTff_varParserRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//vartype=Tff_type_expression
		public Assignment getVartypeAssignment_2() { return cVartypeAssignment_2; }
		
		//Tff_type_expression
		public RuleCall getVartypeTff_type_expressionParserRuleCall_2_0() { return cVartypeTff_type_expressionParserRuleCall_2_0; }
	}
	public class Tff_quantifier_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Tff_quantifier_expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cQuantifierAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cQuantifierAlternatives_0_0 = (Alternatives)cQuantifierAssignment_0.eContents().get(0);
		private final Keyword cQuantifierExclamationMarkKeyword_0_0_0 = (Keyword)cQuantifierAlternatives_0_0.eContents().get(0);
		private final Keyword cQuantifierQuestionMarkKeyword_0_0_1 = (Keyword)cQuantifierAlternatives_0_0.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParamAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParamTff_variable_listParserRuleCall_2_0 = (RuleCall)cParamAssignment_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cColonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cExpAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cExpTff_expressionParserRuleCall_5_0 = (RuleCall)cExpAssignment_5.eContents().get(0);
		
		//Tff_quantifier_expression Tff_expression:
		//	quantifier=('!' // for all
		//	| '?' //there exists
		//) '[' param=Tff_variable_list ']' ':' exp=Tff_expression;
		@Override public ParserRule getRule() { return rule; }
		
		//quantifier=('!' // for all
		//| '?' //there exists
		//) '[' param=Tff_variable_list ']' ':' exp=Tff_expression
		public Group getGroup() { return cGroup; }
		
		//quantifier=('!' // for all
		//| '?' //there exists
		//)
		public Assignment getQuantifierAssignment_0() { return cQuantifierAssignment_0; }
		
		//('!' // for all
		//| '?' //there exists
		//)
		public Alternatives getQuantifierAlternatives_0_0() { return cQuantifierAlternatives_0_0; }
		
		//'!'
		public Keyword getQuantifierExclamationMarkKeyword_0_0_0() { return cQuantifierExclamationMarkKeyword_0_0_0; }
		
		//'?'
		public Keyword getQuantifierQuestionMarkKeyword_0_0_1() { return cQuantifierQuestionMarkKeyword_0_0_1; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }
		
		//param=Tff_variable_list
		public Assignment getParamAssignment_2() { return cParamAssignment_2; }
		
		//Tff_variable_list
		public RuleCall getParamTff_variable_listParserRuleCall_2_0() { return cParamTff_variable_listParserRuleCall_2_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
		
		//':'
		public Keyword getColonKeyword_4() { return cColonKeyword_4; }
		
		//exp=Tff_expression
		public Assignment getExpAssignment_5() { return cExpAssignment_5; }
		
		//Tff_expression
		public RuleCall getExpTff_expressionParserRuleCall_5_0() { return cExpTff_expressionParserRuleCall_5_0; }
	}
	public class Tff_type_quantifier_epressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Tff_type_quantifier_epression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cQuantifierAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cQuantifierExclamationMarkGreaterThanSignKeyword_0_0 = (Keyword)cQuantifierAssignment_0.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParamAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParamTff_variable_listParserRuleCall_2_0 = (RuleCall)cParamAssignment_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cColonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cExpAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cExpTff_type_expressionParserRuleCall_5_0 = (RuleCall)cExpAssignment_5.eContents().get(0);
		
		//Tff_type_quantifier_epression Tff_expression:
		//	quantifier='!>' //????
		//	'[' param=Tff_variable_list ']' ':' exp=Tff_type_expression;
		@Override public ParserRule getRule() { return rule; }
		
		//quantifier='!>' //????
		//'[' param=Tff_variable_list ']' ':' exp=Tff_type_expression
		public Group getGroup() { return cGroup; }
		
		//quantifier='!>'
		public Assignment getQuantifierAssignment_0() { return cQuantifierAssignment_0; }
		
		//'!>'
		public Keyword getQuantifierExclamationMarkGreaterThanSignKeyword_0_0() { return cQuantifierExclamationMarkGreaterThanSignKeyword_0_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }
		
		//param=Tff_variable_list
		public Assignment getParamAssignment_2() { return cParamAssignment_2; }
		
		//Tff_variable_list
		public RuleCall getParamTff_variable_listParserRuleCall_2_0() { return cParamTff_variable_listParserRuleCall_2_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
		
		//':'
		public Keyword getColonKeyword_4() { return cColonKeyword_4; }
		
		//exp=Tff_type_expression
		public Assignment getExpAssignment_5() { return cExpAssignment_5; }
		
		//Tff_type_expression
		public RuleCall getExpTff_type_expressionParserRuleCall_5_0() { return cExpTff_type_expressionParserRuleCall_5_0; }
	}
	public class Tff_variable_listElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Tff_variable_list");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cParamsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cParamsTff_var_declarationParserRuleCall_0_0 = (RuleCall)cParamsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cParamsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cParamsTff_var_declarationParserRuleCall_1_1_0 = (RuleCall)cParamsAssignment_1_1.eContents().get(0);
		
		////TODO: the syntax colisions here are insane! what does ":" mean?
		//Tff_variable_list:
		//	params+=Tff_var_declaration (',' params+=Tff_var_declaration)*;
		@Override public ParserRule getRule() { return rule; }
		
		//params+=Tff_var_declaration (',' params+=Tff_var_declaration)*
		public Group getGroup() { return cGroup; }
		
		//params+=Tff_var_declaration
		public Assignment getParamsAssignment_0() { return cParamsAssignment_0; }
		
		//Tff_var_declaration
		public RuleCall getParamsTff_var_declarationParserRuleCall_0_0() { return cParamsTff_var_declarationParserRuleCall_0_0; }
		
		//(',' params+=Tff_var_declaration)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//params+=Tff_var_declaration
		public Assignment getParamsAssignment_1_1() { return cParamsAssignment_1_1; }
		
		//Tff_var_declaration
		public RuleCall getParamsTff_var_declarationParserRuleCall_1_1_0() { return cParamsTff_var_declarationParserRuleCall_1_1_0; }
	}
	public class Cnf_inputElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Cnf_input");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCnf_rootParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIncludeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		////////////////////////////////////////////////////////////////////////////////////
		//// CNF
		//Cnf_input:
		//	Cnf_root | Include;
		@Override public ParserRule getRule() { return rule; }
		
		//Cnf_root | Include
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Cnf_root
		public RuleCall getCnf_rootParserRuleCall_0() { return cCnf_rootParserRuleCall_0; }
		
		//Include
		public RuleCall getIncludeParserRuleCall_1() { return cIncludeParserRuleCall_1; }
	}
	public class Cnf_rootElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Cnf_root");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCnfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cNameAlternatives_2_0 = (Alternatives)cNameAssignment_2.eContents().get(0);
		private final RuleCall cNameLower_token_and_keywordParserRuleCall_2_0_0 = (RuleCall)cNameAlternatives_2_0.eContents().get(0);
		private final RuleCall cNameSTRINGTerminalRuleCall_2_0_1 = (RuleCall)cNameAlternatives_2_0.eContents().get(1);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cFormula_roleAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final Alternatives cFormula_roleAlternatives_4_0 = (Alternatives)cFormula_roleAssignment_4.eContents().get(0);
		private final Keyword cFormula_roleAxiomKeyword_4_0_0 = (Keyword)cFormula_roleAlternatives_4_0.eContents().get(0);
		private final Keyword cFormula_roleHypothesisKeyword_4_0_1 = (Keyword)cFormula_roleAlternatives_4_0.eContents().get(1);
		private final Keyword cFormula_roleNegated_conjectureKeyword_4_0_2 = (Keyword)cFormula_roleAlternatives_4_0.eContents().get(2);
		private final Keyword cFormula_rolePlainKeyword_4_0_3 = (Keyword)cFormula_roleAlternatives_4_0.eContents().get(3);
		private final Keyword cCommaKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cExpAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cExpCnf_formula_type_definitionParserRuleCall_6_0 = (RuleCall)cExpAssignment_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Keyword cFullStopKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//Cnf_root:
		//	'cnf' '(' name=(Lower_token_and_keyword | STRING)
		//	',' formula_role=('axiom' | 'hypothesis' | 'negated_conjecture' |
		//	'plain' //TODO: check if this has been depricated
		//)
		//	',' exp=Cnf_formula_type_definition
		//	')' '.';
		@Override public ParserRule getRule() { return rule; }
		
		//'cnf' '(' name=(Lower_token_and_keyword | STRING) ',' formula_role=('axiom' | 'hypothesis' | 'negated_conjecture' |
		//'plain' //TODO: check if this has been depricated
		//) ',' exp=Cnf_formula_type_definition ')' '.'
		public Group getGroup() { return cGroup; }
		
		//'cnf'
		public Keyword getCnfKeyword_0() { return cCnfKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//name=(Lower_token_and_keyword | STRING)
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//(Lower_token_and_keyword | STRING)
		public Alternatives getNameAlternatives_2_0() { return cNameAlternatives_2_0; }
		
		//Lower_token_and_keyword
		public RuleCall getNameLower_token_and_keywordParserRuleCall_2_0_0() { return cNameLower_token_and_keywordParserRuleCall_2_0_0; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_2_0_1() { return cNameSTRINGTerminalRuleCall_2_0_1; }
		
		//','
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//formula_role=('axiom' | 'hypothesis' | 'negated_conjecture' | 'plain' //TODO: check if this has been depricated
		//)
		public Assignment getFormula_roleAssignment_4() { return cFormula_roleAssignment_4; }
		
		//('axiom' | 'hypothesis' | 'negated_conjecture' | 'plain' //TODO: check if this has been depricated
		//)
		public Alternatives getFormula_roleAlternatives_4_0() { return cFormula_roleAlternatives_4_0; }
		
		//'axiom'
		public Keyword getFormula_roleAxiomKeyword_4_0_0() { return cFormula_roleAxiomKeyword_4_0_0; }
		
		//'hypothesis'
		public Keyword getFormula_roleHypothesisKeyword_4_0_1() { return cFormula_roleHypothesisKeyword_4_0_1; }
		
		//'negated_conjecture'
		public Keyword getFormula_roleNegated_conjectureKeyword_4_0_2() { return cFormula_roleNegated_conjectureKeyword_4_0_2; }
		
		//'plain'
		public Keyword getFormula_rolePlainKeyword_4_0_3() { return cFormula_rolePlainKeyword_4_0_3; }
		
		//','
		public Keyword getCommaKeyword_5() { return cCommaKeyword_5; }
		
		//exp=Cnf_formula_type_definition
		public Assignment getExpAssignment_6() { return cExpAssignment_6; }
		
		//Cnf_formula_type_definition
		public RuleCall getExpCnf_formula_type_definitionParserRuleCall_6_0() { return cExpCnf_formula_type_definitionParserRuleCall_6_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }
		
		//'.'
		public Keyword getFullStopKeyword_8() { return cFullStopKeyword_8; }
	}
	public class Cnf_formula_type_definitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Cnf_formula_type_definition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cDisjunctionAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cDisjunctionCnf_orParserRuleCall_0_1_0 = (RuleCall)cDisjunctionAssignment_0_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cDisjunctionAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cDisjunctionCnf_orParserRuleCall_1_0 = (RuleCall)cDisjunctionAssignment_1.eContents().get(0);
		
		//Cnf_formula_type_definition:
		//	'(' disjunction=Cnf_or ')' | disjunction=Cnf_or;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' disjunction=Cnf_or ')' | disjunction=Cnf_or
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' disjunction=Cnf_or ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//disjunction=Cnf_or
		public Assignment getDisjunctionAssignment_0_1() { return cDisjunctionAssignment_0_1; }
		
		//Cnf_or
		public RuleCall getDisjunctionCnf_orParserRuleCall_0_1_0() { return cDisjunctionCnf_orParserRuleCall_0_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//disjunction=Cnf_or
		public Assignment getDisjunctionAssignment_1() { return cDisjunctionAssignment_1; }
		
		//Cnf_or
		public RuleCall getDisjunctionCnf_orParserRuleCall_1_0() { return cDisjunctionCnf_orParserRuleCall_1_0; }
	}
	public class Cnf_orElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Cnf_or");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOrAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOrCnf_notParserRuleCall_0_0 = (RuleCall)cOrAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cVerticalLineKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cOrAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOrCnf_notParserRuleCall_1_1_0 = (RuleCall)cOrAssignment_1_1.eContents().get(0);
		
		//Cnf_or:
		//	or+=Cnf_not ('|' or+=Cnf_not)*;
		@Override public ParserRule getRule() { return rule; }
		
		//or+=Cnf_not ('|' or+=Cnf_not)*
		public Group getGroup() { return cGroup; }
		
		//or+=Cnf_not
		public Assignment getOrAssignment_0() { return cOrAssignment_0; }
		
		//Cnf_not
		public RuleCall getOrCnf_notParserRuleCall_0_0() { return cOrCnf_notParserRuleCall_0_0; }
		
		//('|' or+=Cnf_not)*
		public Group getGroup_1() { return cGroup_1; }
		
		//'|'
		public Keyword getVerticalLineKeyword_1_0() { return cVerticalLineKeyword_1_0; }
		
		//or+=Cnf_not
		public Assignment getOrAssignment_1_1() { return cOrAssignment_1_1; }
		
		//Cnf_not
		public RuleCall getOrCnf_notParserRuleCall_1_1_0() { return cOrCnf_notParserRuleCall_1_1_0; }
	}
	public class Cnf_notElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Cnf_not");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNegatedAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNegatedTildeKeyword_0_0 = (Keyword)cNegatedAssignment_0.eContents().get(0);
		private final Assignment cLiteralAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLiteralCnf_equalityParserRuleCall_1_0 = (RuleCall)cLiteralAssignment_1.eContents().get(0);
		
		//Cnf_not:
		//	negated?='~'? literal=Cnf_equality;
		@Override public ParserRule getRule() { return rule; }
		
		//negated?='~'? literal=Cnf_equality
		public Group getGroup() { return cGroup; }
		
		//negated?='~'?
		public Assignment getNegatedAssignment_0() { return cNegatedAssignment_0; }
		
		//'~'
		public Keyword getNegatedTildeKeyword_0_0() { return cNegatedTildeKeyword_0_0; }
		
		//literal=Cnf_equality
		public Assignment getLiteralAssignment_1() { return cLiteralAssignment_1; }
		
		//Cnf_equality
		public RuleCall getLiteralCnf_equalityParserRuleCall_1_0() { return cLiteralCnf_equalityParserRuleCall_1_0; }
	}
	public class Cnf_equalityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Cnf_equality");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExpLAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExpLCnf_expressionParserRuleCall_0_0 = (RuleCall)cExpLAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cEqAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Alternatives cEqAlternatives_1_0_0 = (Alternatives)cEqAssignment_1_0.eContents().get(0);
		private final Keyword cEqEqualsSignKeyword_1_0_0_0 = (Keyword)cEqAlternatives_1_0_0.eContents().get(0);
		private final Keyword cEqExclamationMarkEqualsSignKeyword_1_0_0_1 = (Keyword)cEqAlternatives_1_0_0.eContents().get(1);
		private final Assignment cExpRAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExpRCnf_expressionParserRuleCall_1_1_0 = (RuleCall)cExpRAssignment_1_1.eContents().get(0);
		
		////TODO: cange nagated to something that is true when the formula is true and false otherwise
		////TODO: merge down
		//Cnf_equality:
		//	expL=Cnf_expression (eq=('=' | '!=') expR=Cnf_expression)?;
		@Override public ParserRule getRule() { return rule; }
		
		//expL=Cnf_expression (eq=('=' | '!=') expR=Cnf_expression)?
		public Group getGroup() { return cGroup; }
		
		//expL=Cnf_expression
		public Assignment getExpLAssignment_0() { return cExpLAssignment_0; }
		
		//Cnf_expression
		public RuleCall getExpLCnf_expressionParserRuleCall_0_0() { return cExpLCnf_expressionParserRuleCall_0_0; }
		
		//(eq=('=' | '!=') expR=Cnf_expression)?
		public Group getGroup_1() { return cGroup_1; }
		
		//eq=('=' | '!=')
		public Assignment getEqAssignment_1_0() { return cEqAssignment_1_0; }
		
		//('=' | '!=')
		public Alternatives getEqAlternatives_1_0_0() { return cEqAlternatives_1_0_0; }
		
		//'='
		public Keyword getEqEqualsSignKeyword_1_0_0_0() { return cEqEqualsSignKeyword_1_0_0_0; }
		
		//'!='
		public Keyword getEqExclamationMarkEqualsSignKeyword_1_0_0_1() { return cEqExclamationMarkEqualsSignKeyword_1_0_0_1; }
		
		//expR=Cnf_expression
		public Assignment getExpRAssignment_1_1() { return cExpRAssignment_1_1; }
		
		//Cnf_expression
		public RuleCall getExpRCnf_expressionParserRuleCall_1_1_0() { return cExpRCnf_expressionParserRuleCall_1_1_0; }
	}
	public class Cnf_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Cnf_expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCnf_constantParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCnf_varParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Assignment cCnf_expAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cCnf_expCnf_statement_literalParserRuleCall_2_0 = (RuleCall)cCnf_expAssignment_2.eContents().get(0);
		
		////TODO: file bug report:
		////cnf_not:
		////        ('~')? (cnf_exp | cnf_equality);
		////
		////cnf_equality: cnf_exp '=' cnf_exp;
		//Cnf_expression:
		//	Cnf_constant | Cnf_var | cnf_exp=Cnf_statement_literal;
		@Override public ParserRule getRule() { return rule; }
		
		//Cnf_constant | Cnf_var | cnf_exp=Cnf_statement_literal
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Cnf_constant
		public RuleCall getCnf_constantParserRuleCall_0() { return cCnf_constantParserRuleCall_0; }
		
		//Cnf_var
		public RuleCall getCnf_varParserRuleCall_1() { return cCnf_varParserRuleCall_1; }
		
		//cnf_exp=Cnf_statement_literal
		public Assignment getCnf_expAssignment_2() { return cCnf_expAssignment_2; }
		
		//Cnf_statement_literal
		public RuleCall getCnf_expCnf_statement_literalParserRuleCall_2_0() { return cCnf_expCnf_statement_literalParserRuleCall_2_0; }
	}
	public class Cnf_constantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Cnf_constant");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cNameAlternatives_0_0 = (Alternatives)cNameAssignment_0.eContents().get(0);
		private final RuleCall cNameLower_token_and_keywordParserRuleCall_0_0_0 = (RuleCall)cNameAlternatives_0_0.eContents().get(0);
		private final RuleCall cNameSTRINGTerminalRuleCall_0_0_1 = (RuleCall)cNameAlternatives_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cParamAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cParamCnf_expressionParserRuleCall_1_1_0 = (RuleCall)cParamAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cCommaKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cParamAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cParamCnf_expressionParserRuleCall_1_2_1_0 = (RuleCall)cParamAssignment_1_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//Cnf_constant:
		//	name=(Lower_token_and_keyword | STRING) ('(' param+=Cnf_expression (',' param+=Cnf_expression)* ')')?;
		@Override public ParserRule getRule() { return rule; }
		
		//name=(Lower_token_and_keyword | STRING) ('(' param+=Cnf_expression (',' param+=Cnf_expression)* ')')?
		public Group getGroup() { return cGroup; }
		
		//name=(Lower_token_and_keyword | STRING)
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//(Lower_token_and_keyword | STRING)
		public Alternatives getNameAlternatives_0_0() { return cNameAlternatives_0_0; }
		
		//Lower_token_and_keyword
		public RuleCall getNameLower_token_and_keywordParserRuleCall_0_0_0() { return cNameLower_token_and_keywordParserRuleCall_0_0_0; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_0_0_1() { return cNameSTRINGTerminalRuleCall_0_0_1; }
		
		//('(' param+=Cnf_expression (',' param+=Cnf_expression)* ')')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//param+=Cnf_expression
		public Assignment getParamAssignment_1_1() { return cParamAssignment_1_1; }
		
		//Cnf_expression
		public RuleCall getParamCnf_expressionParserRuleCall_1_1_0() { return cParamCnf_expressionParserRuleCall_1_1_0; }
		
		//(',' param+=Cnf_expression)*
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//','
		public Keyword getCommaKeyword_1_2_0() { return cCommaKeyword_1_2_0; }
		
		//param+=Cnf_expression
		public Assignment getParamAssignment_1_2_1() { return cParamAssignment_1_2_1; }
		
		//Cnf_expression
		public RuleCall getParamCnf_expressionParserRuleCall_1_2_1_0() { return cParamCnf_expressionParserRuleCall_1_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}
	public class Cnf_varElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Cnf_var");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameUPPER_TOKENTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Cnf_var:
		//	name=UPPER_TOKEN;
		@Override public ParserRule getRule() { return rule; }
		
		//name=UPPER_TOKEN
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//UPPER_TOKEN
		public RuleCall getNameUPPER_TOKENTerminalRuleCall_0() { return cNameUPPER_TOKENTerminalRuleCall_0; }
	}
	public class Cnf_statement_literalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Cnf_statement_literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTrueKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		////TODO: tooltip doc
		////TODO: make more DRY
		//Cnf_statement_literal:
		//	'$true' | '$false';
		@Override public ParserRule getRule() { return rule; }
		
		//'$true' | '$false'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'$true'
		public Keyword getTrueKeyword_0() { return cTrueKeyword_0; }
		
		//'$false'
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }
	}
	public class Thf_inputElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Thf_input");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cThf_rootParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIncludeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		////TODO: compile time type checking would be super cool
		////TODO: should only be able to import file of the same language
		////TODO: import magic
		///////////////////////////////////////////////////////////////////////////
		//// THF
		//Thf_input:
		//	Thf_root | Include;
		@Override public ParserRule getRule() { return rule; }
		
		//Thf_root | Include
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Thf_root
		public RuleCall getThf_rootParserRuleCall_0() { return cThf_rootParserRuleCall_0; }
		
		//Include
		public RuleCall getIncludeParserRuleCall_1() { return cIncludeParserRuleCall_1; }
	}
	public class Thf_rootElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Thf_root");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cThfKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cNameAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final Alternatives cNameAlternatives_0_2_0 = (Alternatives)cNameAssignment_0_2.eContents().get(0);
		private final RuleCall cNameLower_token_and_keywordParserRuleCall_0_2_0_0 = (RuleCall)cNameAlternatives_0_2_0.eContents().get(0);
		private final RuleCall cNameSTRINGTerminalRuleCall_0_2_0_1 = (RuleCall)cNameAlternatives_0_2_0.eContents().get(1);
		private final Keyword cCommaKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final Assignment cFormula_roleAssignment_0_4 = (Assignment)cGroup_0.eContents().get(4);
		private final Keyword cFormula_roleTypeKeyword_0_4_0 = (Keyword)cFormula_roleAssignment_0_4.eContents().get(0);
		private final Keyword cCommaKeyword_0_5 = (Keyword)cGroup_0.eContents().get(5);
		private final Assignment cDefAssignment_0_6 = (Assignment)cGroup_0.eContents().get(6);
		private final RuleCall cDefThf_formula_type_definitionParserRuleCall_0_6_0 = (RuleCall)cDefAssignment_0_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_7 = (Keyword)cGroup_0.eContents().get(7);
		private final Keyword cFullStopKeyword_0_8 = (Keyword)cGroup_0.eContents().get(8);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cThfKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cNameAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cNameAlternatives_1_2_0 = (Alternatives)cNameAssignment_1_2.eContents().get(0);
		private final RuleCall cNameLower_token_and_keywordParserRuleCall_1_2_0_0 = (RuleCall)cNameAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cNameSTRINGTerminalRuleCall_1_2_0_1 = (RuleCall)cNameAlternatives_1_2_0.eContents().get(1);
		private final Keyword cCommaKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cFormula_roleAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final Alternatives cFormula_roleAlternatives_1_4_0 = (Alternatives)cFormula_roleAssignment_1_4.eContents().get(0);
		private final Keyword cFormula_roleAxiomKeyword_1_4_0_0 = (Keyword)cFormula_roleAlternatives_1_4_0.eContents().get(0);
		private final Keyword cFormula_roleHypothesisKeyword_1_4_0_1 = (Keyword)cFormula_roleAlternatives_1_4_0.eContents().get(1);
		private final Keyword cFormula_roleNegated_conjectureKeyword_1_4_0_2 = (Keyword)cFormula_roleAlternatives_1_4_0.eContents().get(2);
		private final Keyword cFormula_roleConjectureKeyword_1_4_0_3 = (Keyword)cFormula_roleAlternatives_1_4_0.eContents().get(3);
		private final Keyword cFormula_roleDefinitionKeyword_1_4_0_4 = (Keyword)cFormula_roleAlternatives_1_4_0.eContents().get(4);
		private final Keyword cFormula_roleLemmaKeyword_1_4_0_5 = (Keyword)cFormula_roleAlternatives_1_4_0.eContents().get(5);
		private final Keyword cCommaKeyword_1_5 = (Keyword)cGroup_1.eContents().get(5);
		private final Assignment cThf_expAssignment_1_6 = (Assignment)cGroup_1.eContents().get(6);
		private final RuleCall cThf_expThf_expressionParserRuleCall_1_6_0 = (RuleCall)cThf_expAssignment_1_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_7 = (Keyword)cGroup_1.eContents().get(7);
		private final Keyword cFullStopKeyword_1_8 = (Keyword)cGroup_1.eContents().get(8);
		
		//Thf_root:
		//	'thf' '(' name=(Lower_token_and_keyword | STRING)
		//	',' formula_role='type'
		//	',' def=Thf_formula_type_definition
		//	')' '.'
		//	|
		//	'thf' '(' name=(Lower_token_and_keyword | STRING)
		//	',' formula_role=('axiom' | 'hypothesis' | 'negated_conjecture' | 'conjecture' | 'definition' | 'lemma')
		//	',' thf_exp=Thf_expression
		//	')' '.';
		@Override public ParserRule getRule() { return rule; }
		
		//'thf' '(' name=(Lower_token_and_keyword | STRING) ',' formula_role='type' ',' def=Thf_formula_type_definition ')' '.' |
		//'thf' '(' name=(Lower_token_and_keyword | STRING) ',' formula_role=('axiom' | 'hypothesis' | 'negated_conjecture' |
		//'conjecture' | 'definition' | 'lemma') ',' thf_exp=Thf_expression ')' '.'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'thf' '(' name=(Lower_token_and_keyword | STRING) ',' formula_role='type' ',' def=Thf_formula_type_definition ')' '.'
		public Group getGroup_0() { return cGroup_0; }
		
		//'thf'
		public Keyword getThfKeyword_0_0() { return cThfKeyword_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_1() { return cLeftParenthesisKeyword_0_1; }
		
		//name=(Lower_token_and_keyword | STRING)
		public Assignment getNameAssignment_0_2() { return cNameAssignment_0_2; }
		
		//(Lower_token_and_keyword | STRING)
		public Alternatives getNameAlternatives_0_2_0() { return cNameAlternatives_0_2_0; }
		
		//Lower_token_and_keyword
		public RuleCall getNameLower_token_and_keywordParserRuleCall_0_2_0_0() { return cNameLower_token_and_keywordParserRuleCall_0_2_0_0; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_0_2_0_1() { return cNameSTRINGTerminalRuleCall_0_2_0_1; }
		
		//','
		public Keyword getCommaKeyword_0_3() { return cCommaKeyword_0_3; }
		
		//formula_role='type'
		public Assignment getFormula_roleAssignment_0_4() { return cFormula_roleAssignment_0_4; }
		
		//'type'
		public Keyword getFormula_roleTypeKeyword_0_4_0() { return cFormula_roleTypeKeyword_0_4_0; }
		
		//','
		public Keyword getCommaKeyword_0_5() { return cCommaKeyword_0_5; }
		
		//def=Thf_formula_type_definition
		public Assignment getDefAssignment_0_6() { return cDefAssignment_0_6; }
		
		//Thf_formula_type_definition
		public RuleCall getDefThf_formula_type_definitionParserRuleCall_0_6_0() { return cDefThf_formula_type_definitionParserRuleCall_0_6_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_7() { return cRightParenthesisKeyword_0_7; }
		
		//'.'
		public Keyword getFullStopKeyword_0_8() { return cFullStopKeyword_0_8; }
		
		//'thf' '(' name=(Lower_token_and_keyword | STRING) ',' formula_role=('axiom' | 'hypothesis' | 'negated_conjecture' |
		//'conjecture' | 'definition' | 'lemma') ',' thf_exp=Thf_expression ')' '.'
		public Group getGroup_1() { return cGroup_1; }
		
		//'thf'
		public Keyword getThfKeyword_1_0() { return cThfKeyword_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }
		
		//name=(Lower_token_and_keyword | STRING)
		public Assignment getNameAssignment_1_2() { return cNameAssignment_1_2; }
		
		//(Lower_token_and_keyword | STRING)
		public Alternatives getNameAlternatives_1_2_0() { return cNameAlternatives_1_2_0; }
		
		//Lower_token_and_keyword
		public RuleCall getNameLower_token_and_keywordParserRuleCall_1_2_0_0() { return cNameLower_token_and_keywordParserRuleCall_1_2_0_0; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_1_2_0_1() { return cNameSTRINGTerminalRuleCall_1_2_0_1; }
		
		//','
		public Keyword getCommaKeyword_1_3() { return cCommaKeyword_1_3; }
		
		//formula_role=('axiom' | 'hypothesis' | 'negated_conjecture' | 'conjecture' | 'definition' | 'lemma')
		public Assignment getFormula_roleAssignment_1_4() { return cFormula_roleAssignment_1_4; }
		
		//('axiom' | 'hypothesis' | 'negated_conjecture' | 'conjecture' | 'definition' | 'lemma')
		public Alternatives getFormula_roleAlternatives_1_4_0() { return cFormula_roleAlternatives_1_4_0; }
		
		//'axiom'
		public Keyword getFormula_roleAxiomKeyword_1_4_0_0() { return cFormula_roleAxiomKeyword_1_4_0_0; }
		
		//'hypothesis'
		public Keyword getFormula_roleHypothesisKeyword_1_4_0_1() { return cFormula_roleHypothesisKeyword_1_4_0_1; }
		
		//'negated_conjecture'
		public Keyword getFormula_roleNegated_conjectureKeyword_1_4_0_2() { return cFormula_roleNegated_conjectureKeyword_1_4_0_2; }
		
		//'conjecture'
		public Keyword getFormula_roleConjectureKeyword_1_4_0_3() { return cFormula_roleConjectureKeyword_1_4_0_3; }
		
		//'definition'
		public Keyword getFormula_roleDefinitionKeyword_1_4_0_4() { return cFormula_roleDefinitionKeyword_1_4_0_4; }
		
		//'lemma'
		public Keyword getFormula_roleLemmaKeyword_1_4_0_5() { return cFormula_roleLemmaKeyword_1_4_0_5; }
		
		//','
		public Keyword getCommaKeyword_1_5() { return cCommaKeyword_1_5; }
		
		//thf_exp=Thf_expression
		public Assignment getThf_expAssignment_1_6() { return cThf_expAssignment_1_6; }
		
		//Thf_expression
		public RuleCall getThf_expThf_expressionParserRuleCall_1_6_0() { return cThf_expThf_expressionParserRuleCall_1_6_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_7() { return cRightParenthesisKeyword_1_7; }
		
		//'.'
		public Keyword getFullStopKeyword_1_8() { return cFullStopKeyword_1_8; }
	}
	public class Thf_formula_type_definitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Thf_formula_type_definition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cThf_formula_type_definitionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cNameAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Alternatives cNameAlternatives_1_0_0 = (Alternatives)cNameAssignment_1_0.eContents().get(0);
		private final RuleCall cNameLower_token_and_keywordParserRuleCall_1_0_0_0 = (RuleCall)cNameAlternatives_1_0_0.eContents().get(0);
		private final RuleCall cNameSTRINGTerminalRuleCall_1_0_0_1 = (RuleCall)cNameAlternatives_1_0_0.eContents().get(1);
		private final Keyword cColonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cExpAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExpThf_type_expressionParserRuleCall_1_2_0 = (RuleCall)cExpAssignment_1_2.eContents().get(0);
		
		//Thf_formula_type_definition:
		//	'(' Thf_formula_type_definition ')' | name=(Lower_token_and_keyword | STRING) ':' exp=Thf_type_expression;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' Thf_formula_type_definition ')' | name=(Lower_token_and_keyword | STRING) ':' exp=Thf_type_expression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' Thf_formula_type_definition ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//Thf_formula_type_definition
		public RuleCall getThf_formula_type_definitionParserRuleCall_0_1() { return cThf_formula_type_definitionParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//name=(Lower_token_and_keyword | STRING) ':' exp=Thf_type_expression
		public Group getGroup_1() { return cGroup_1; }
		
		//name=(Lower_token_and_keyword | STRING)
		public Assignment getNameAssignment_1_0() { return cNameAssignment_1_0; }
		
		//(Lower_token_and_keyword | STRING)
		public Alternatives getNameAlternatives_1_0_0() { return cNameAlternatives_1_0_0; }
		
		//Lower_token_and_keyword
		public RuleCall getNameLower_token_and_keywordParserRuleCall_1_0_0_0() { return cNameLower_token_and_keywordParserRuleCall_1_0_0_0; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_1_0_0_1() { return cNameSTRINGTerminalRuleCall_1_0_0_1; }
		
		//':'
		public Keyword getColonKeyword_1_1() { return cColonKeyword_1_1; }
		
		//exp=Thf_type_expression
		public Assignment getExpAssignment_1_2() { return cExpAssignment_1_2; }
		
		//Thf_type_expression
		public RuleCall getExpThf_type_expressionParserRuleCall_1_2_0() { return cExpThf_type_expressionParserRuleCall_1_2_0; }
	}
	public class Thf_type_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Thf_type_expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cThf_terminal_type_expressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOperLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpGreaterThanSignKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightThf_terminal_type_expressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		////these operators are left associative, as god intended
		////TODO: should we AST modle these as Tff_type_constant with 2 params?
		//Thf_type_expression:
		//	Thf_terminal_type_expression ({oper.left=current} op='>' right+=Thf_terminal_type_expression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Thf_terminal_type_expression ({oper.left=current} op='>' right+=Thf_terminal_type_expression)*
		public Group getGroup() { return cGroup; }
		
		//Thf_terminal_type_expression
		public RuleCall getThf_terminal_type_expressionParserRuleCall_0() { return cThf_terminal_type_expressionParserRuleCall_0; }
		
		//({oper.left=current} op='>' right+=Thf_terminal_type_expression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{oper.left=current}
		public Action getOperLeftAction_1_0() { return cOperLeftAction_1_0; }
		
		//op='>'
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//'>'
		public Keyword getOpGreaterThanSignKeyword_1_1_0() { return cOpGreaterThanSignKeyword_1_1_0; }
		
		//right+=Thf_terminal_type_expression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Thf_terminal_type_expression
		public RuleCall getRightThf_terminal_type_expressionParserRuleCall_1_2_0() { return cRightThf_terminal_type_expressionParserRuleCall_1_2_0; }
	}
	public class Thf_terminal_type_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Thf_terminal_type_expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cThf_type_atomParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cThf_type_expressionParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//Thf_terminal_type_expression Thf_type_expression:
		//	Thf_type_atom
		//	| '(' Thf_type_expression ')';
		@Override public ParserRule getRule() { return rule; }
		
		//Thf_type_atom | '(' Thf_type_expression ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Thf_type_atom
		public RuleCall getThf_type_atomParserRuleCall_0() { return cThf_type_atomParserRuleCall_0; }
		
		//'(' Thf_type_expression ')'
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//Thf_type_expression
		public RuleCall getThf_type_expressionParserRuleCall_1_1() { return cThf_type_expressionParserRuleCall_1_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}
	public class Thf_type_atomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Thf_type_atom");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cThf_type_constantParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cThf_type_literalParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Thf_type_atom:
		//	Thf_type_constant | Thf_type_literal;
		@Override public ParserRule getRule() { return rule; }
		
		//Thf_type_constant | Thf_type_literal
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Thf_type_constant
		public RuleCall getThf_type_constantParserRuleCall_0() { return cThf_type_constantParserRuleCall_0; }
		
		////        thf_var |
		//Thf_type_literal
		public RuleCall getThf_type_literalParserRuleCall_1() { return cThf_type_literalParserRuleCall_1; }
	}
	public class Thf_type_constantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Thf_type_constant");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cNameAlternatives_0 = (Alternatives)cNameAssignment.eContents().get(0);
		private final RuleCall cNameLower_token_and_keywordParserRuleCall_0_0 = (RuleCall)cNameAlternatives_0.eContents().get(0);
		private final RuleCall cNameSTRINGTerminalRuleCall_0_1 = (RuleCall)cNameAlternatives_0.eContents().get(1);
		
		//Thf_type_constant:
		//	name=(Lower_token_and_keyword | STRING);
		@Override public ParserRule getRule() { return rule; }
		
		//name=(Lower_token_and_keyword | STRING)
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//(Lower_token_and_keyword | STRING)
		public Alternatives getNameAlternatives_0() { return cNameAlternatives_0; }
		
		//Lower_token_and_keyword
		public RuleCall getNameLower_token_and_keywordParserRuleCall_0_0() { return cNameLower_token_and_keywordParserRuleCall_0_0; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_0_1() { return cNameSTRINGTerminalRuleCall_0_1; }
	}
	public class Thf_type_literalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Thf_type_literal");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cNameAlternatives_0 = (Alternatives)cNameAssignment.eContents().get(0);
		private final Keyword cNameIKeyword_0_0 = (Keyword)cNameAlternatives_0.eContents().get(0);
		private final Keyword cNameOKeyword_0_1 = (Keyword)cNameAlternatives_0.eContents().get(1);
		private final Keyword cNameTTypeKeyword_0_2 = (Keyword)cNameAlternatives_0.eContents().get(2);
		
		////('(' param+=tff_type_atom (',' param+=tff_type_atom)* ')')?;
		//Thf_type_literal Thf_type_constant:
		//	name=('$i' | '$o' | '$tType');
		@Override public ParserRule getRule() { return rule; }
		
		//name=('$i' | '$o' | '$tType')
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//('$i' | '$o' | '$tType')
		public Alternatives getNameAlternatives_0() { return cNameAlternatives_0; }
		
		//'$i'
		public Keyword getNameIKeyword_0_0() { return cNameIKeyword_0_0; }
		
		//'$o'
		public Keyword getNameOKeyword_0_1() { return cNameOKeyword_0_1; }
		
		//'$tType'
		public Keyword getNameTTypeKeyword_0_2() { return cNameTTypeKeyword_0_2; }
	}
	public class Thf_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Thf_expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cThf_terminating_expressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpThf_binary_operatorParserRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightThf_terminating_expressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		////type=[thf_formula_type_definition]
		//Thf_expression:
		//	Thf_terminating_expression ({binary.left=current} op=Thf_binary_operator right=Thf_terminating_expression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Thf_terminating_expression ({binary.left=current} op=Thf_binary_operator right=Thf_terminating_expression)*
		public Group getGroup() { return cGroup; }
		
		//Thf_terminating_expression
		public RuleCall getThf_terminating_expressionParserRuleCall_0() { return cThf_terminating_expressionParserRuleCall_0; }
		
		//({binary.left=current} op=Thf_binary_operator right=Thf_terminating_expression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{binary.left=current}
		public Action getBinaryLeftAction_1_0() { return cBinaryLeftAction_1_0; }
		
		//op=Thf_binary_operator
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//Thf_binary_operator
		public RuleCall getOpThf_binary_operatorParserRuleCall_1_1_0() { return cOpThf_binary_operatorParserRuleCall_1_1_0; }
		
		//right=Thf_terminating_expression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Thf_terminating_expression
		public RuleCall getRightThf_terminating_expressionParserRuleCall_1_2_0() { return cRightThf_terminating_expressionParserRuleCall_1_2_0; }
	}
	public class Thf_terminating_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Thf_terminating_expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cThf_atomAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cThf_atomThf_atomParserRuleCall_0_0 = (RuleCall)cThf_atomAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cThf_expressionParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Assignment cThf_negationAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final Keyword cThf_negationTildeKeyword_2_0_0 = (Keyword)cThf_negationAssignment_2_0.eContents().get(0);
		private final Assignment cThf_expAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cThf_expThf_expressionParserRuleCall_2_1_0 = (RuleCall)cThf_expAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Assignment cOpAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cOpThf_unary_operatorParserRuleCall_3_0_0 = (RuleCall)cOpAssignment_3_0.eContents().get(0);
		private final Assignment cThf_expAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cThf_expThf_expressionParserRuleCall_3_1_0 = (RuleCall)cThf_expAssignment_3_1.eContents().get(0);
		private final Assignment cThf_expAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final RuleCall cThf_expThf_quantifier_expressionParserRuleCall_4_0 = (RuleCall)cThf_expAssignment_4.eContents().get(0);
		
		//Thf_terminating_expression Thf_expression:
		//	thf_atom=Thf_atom |
		//	'(' Thf_expression ')' | thf_negation?='~' thf_exp=Thf_expression | op=Thf_unary_operator thf_exp=Thf_expression |
		//	thf_exp=Thf_quantifier_expression;
		@Override public ParserRule getRule() { return rule; }
		
		//thf_atom=Thf_atom | '(' Thf_expression ')' | thf_negation?='~' thf_exp=Thf_expression | op=Thf_unary_operator
		//thf_exp=Thf_expression | thf_exp=Thf_quantifier_expression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//thf_atom=Thf_atom
		public Assignment getThf_atomAssignment_0() { return cThf_atomAssignment_0; }
		
		//Thf_atom
		public RuleCall getThf_atomThf_atomParserRuleCall_0_0() { return cThf_atomThf_atomParserRuleCall_0_0; }
		
		//'(' Thf_expression ')'
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//Thf_expression
		public RuleCall getThf_expressionParserRuleCall_1_1() { return cThf_expressionParserRuleCall_1_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
		
		//thf_negation?='~' thf_exp=Thf_expression
		public Group getGroup_2() { return cGroup_2; }
		
		//thf_negation?='~'
		public Assignment getThf_negationAssignment_2_0() { return cThf_negationAssignment_2_0; }
		
		//'~'
		public Keyword getThf_negationTildeKeyword_2_0_0() { return cThf_negationTildeKeyword_2_0_0; }
		
		//thf_exp=Thf_expression
		public Assignment getThf_expAssignment_2_1() { return cThf_expAssignment_2_1; }
		
		//Thf_expression
		public RuleCall getThf_expThf_expressionParserRuleCall_2_1_0() { return cThf_expThf_expressionParserRuleCall_2_1_0; }
		
		//op=Thf_unary_operator thf_exp=Thf_expression
		public Group getGroup_3() { return cGroup_3; }
		
		//op=Thf_unary_operator
		public Assignment getOpAssignment_3_0() { return cOpAssignment_3_0; }
		
		//Thf_unary_operator
		public RuleCall getOpThf_unary_operatorParserRuleCall_3_0_0() { return cOpThf_unary_operatorParserRuleCall_3_0_0; }
		
		//thf_exp=Thf_expression
		public Assignment getThf_expAssignment_3_1() { return cThf_expAssignment_3_1; }
		
		//Thf_expression
		public RuleCall getThf_expThf_expressionParserRuleCall_3_1_0() { return cThf_expThf_expressionParserRuleCall_3_1_0; }
		
		//thf_exp=Thf_quantifier_expression
		public Assignment getThf_expAssignment_4() { return cThf_expAssignment_4; }
		
		//Thf_quantifier_expression
		public RuleCall getThf_expThf_quantifier_expressionParserRuleCall_4_0() { return cThf_expThf_quantifier_expressionParserRuleCall_4_0; }
	}
	public class Thf_unary_operatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Thf_unary_operator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cCommercialAtKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cQuestionMarkQuestionMarkKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cExclamationMarkExclamationMarkKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cAmpersandKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cVerticalLineKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cEqualsSignGreaterThanSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		
		////I don't know what the fuck any of these do
		//Thf_unary_operator:
		//	'@' | '??' | '!!' | '&' | '|' | '=>';
		@Override public ParserRule getRule() { return rule; }
		
		//'@' | '??' | '!!' | '&' | '|' | '=>'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'@'
		public Keyword getCommercialAtKeyword_0() { return cCommercialAtKeyword_0; }
		
		//'??'
		public Keyword getQuestionMarkQuestionMarkKeyword_1() { return cQuestionMarkQuestionMarkKeyword_1; }
		
		//'!!'
		public Keyword getExclamationMarkExclamationMarkKeyword_2() { return cExclamationMarkExclamationMarkKeyword_2; }
		
		//'&'
		public Keyword getAmpersandKeyword_3() { return cAmpersandKeyword_3; }
		
		//'|'
		public Keyword getVerticalLineKeyword_4() { return cVerticalLineKeyword_4; }
		
		//'=>'
		public Keyword getEqualsSignGreaterThanSignKeyword_5() { return cEqualsSignGreaterThanSignKeyword_5; }
	}
	public class Thf_binary_operatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Thf_binary_operator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAmpersandKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cEqualsSignGreaterThanSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cVerticalLineKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cCommercialAtKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cEqualsSignKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cExclamationMarkEqualsSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cLessThanSignEqualsSignKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cLessThanSignEqualsSignGreaterThanSignKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cLessThanSignTildeGreaterThanSignKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		
		//Thf_binary_operator:
		//	'&' | '=>' | '|'
		//	| '@' // (denoting apply) is left-associative and lambda is right-associative. //TODO: deal with asocativity crap
		//	//^ [X] : ^ [Y] : f @ g (where f is a <thf_apply_formula> and g is a
		//	//<thf_unitary_formula>) should be parsed as: (^ [X] : (^ [Y] : f)) @ g.
		//	//That is, g is not in the scope of either lambda.
		//	| '=' //TODO: how is this actualy defined?
		//	| '!='
		//	| '<='
		//	| '<=>'
		//	| '<~>';
		@Override public ParserRule getRule() { return rule; }
		
		//'&' | '=>' | '|' | '@' // (denoting apply) is left-associative and lambda is right-associative. //TODO: deal with asocativity crap
		////^ [X] : ^ [Y] : f @ g (where f is a <thf_apply_formula> and g is a
		////<thf_unitary_formula>) should be parsed as: (^ [X] : (^ [Y] : f)) @ g.
		////That is, g is not in the scope of either lambda.
		//| '=' //TODO: how is this actualy defined?
		//| '!=' | '<=' | '<=>' | '<~>'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'&'
		public Keyword getAmpersandKeyword_0() { return cAmpersandKeyword_0; }
		
		//'=>'
		public Keyword getEqualsSignGreaterThanSignKeyword_1() { return cEqualsSignGreaterThanSignKeyword_1; }
		
		//'|'
		public Keyword getVerticalLineKeyword_2() { return cVerticalLineKeyword_2; }
		
		//'@'
		public Keyword getCommercialAtKeyword_3() { return cCommercialAtKeyword_3; }
		
		//'='
		public Keyword getEqualsSignKeyword_4() { return cEqualsSignKeyword_4; }
		
		//'!='
		public Keyword getExclamationMarkEqualsSignKeyword_5() { return cExclamationMarkEqualsSignKeyword_5; }
		
		//'<='
		public Keyword getLessThanSignEqualsSignKeyword_6() { return cLessThanSignEqualsSignKeyword_6; }
		
		//'<=>'
		public Keyword getLessThanSignEqualsSignGreaterThanSignKeyword_7() { return cLessThanSignEqualsSignGreaterThanSignKeyword_7; }
		
		//'<~>'
		public Keyword getLessThanSignTildeGreaterThanSignKeyword_8() { return cLessThanSignTildeGreaterThanSignKeyword_8; }
	}
	public class Thf_atomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Thf_atom");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cThf_constantParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cThf_varParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cThf_atom_literalParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Thf_atom:
		//	Thf_constant | Thf_var | Thf_atom_literal;
		@Override public ParserRule getRule() { return rule; }
		
		//Thf_constant | Thf_var | Thf_atom_literal
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Thf_constant
		public RuleCall getThf_constantParserRuleCall_0() { return cThf_constantParserRuleCall_0; }
		
		//Thf_var
		public RuleCall getThf_varParserRuleCall_1() { return cThf_varParserRuleCall_1; }
		
		//Thf_atom_literal
		public RuleCall getThf_atom_literalParserRuleCall_2() { return cThf_atom_literalParserRuleCall_2; }
	}
	public class Thf_atom_literalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Thf_atom_literal");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cNameAlternatives_0 = (Alternatives)cNameAssignment.eContents().get(0);
		private final Keyword cNameTrueKeyword_0_0 = (Keyword)cNameAlternatives_0.eContents().get(0);
		private final Keyword cNameFalseKeyword_0_1 = (Keyword)cNameAlternatives_0.eContents().get(1);
		
		//Thf_atom_literal Thf_constant:
		//	name=('$true' |
		//	'$false');
		@Override public ParserRule getRule() { return rule; }
		
		//name=('$true' | '$false')
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//('$true' | '$false')
		public Alternatives getNameAlternatives_0() { return cNameAlternatives_0; }
		
		//'$true'
		public Keyword getNameTrueKeyword_0_0() { return cNameTrueKeyword_0_0; }
		
		//'$false'
		public Keyword getNameFalseKeyword_0_1() { return cNameFalseKeyword_0_1; }
	}
	public class Thf_constantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Thf_constant");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cNameAlternatives_0_0 = (Alternatives)cNameAssignment_0.eContents().get(0);
		private final RuleCall cNameLower_token_and_keywordParserRuleCall_0_0_0 = (RuleCall)cNameAlternatives_0_0.eContents().get(0);
		private final RuleCall cNameSTRINGTerminalRuleCall_0_0_1 = (RuleCall)cNameAlternatives_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cThf_paramAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cThf_paramThf_atomParserRuleCall_1_1_0 = (RuleCall)cThf_paramAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cCommaKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cThf_paramAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cThf_paramThf_atomParserRuleCall_1_2_1_0 = (RuleCall)cThf_paramAssignment_1_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//Thf_constant:
		//	name=(Lower_token_and_keyword | STRING) ('(' thf_param+=Thf_atom (',' thf_param+=Thf_atom)* ')')?;
		@Override public ParserRule getRule() { return rule; }
		
		//name=(Lower_token_and_keyword | STRING) ('(' thf_param+=Thf_atom (',' thf_param+=Thf_atom)* ')')?
		public Group getGroup() { return cGroup; }
		
		//name=(Lower_token_and_keyword | STRING)
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//(Lower_token_and_keyword | STRING)
		public Alternatives getNameAlternatives_0_0() { return cNameAlternatives_0_0; }
		
		//Lower_token_and_keyword
		public RuleCall getNameLower_token_and_keywordParserRuleCall_0_0_0() { return cNameLower_token_and_keywordParserRuleCall_0_0_0; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_0_0_1() { return cNameSTRINGTerminalRuleCall_0_0_1; }
		
		//('(' thf_param+=Thf_atom (',' thf_param+=Thf_atom)* ')')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//thf_param+=Thf_atom
		public Assignment getThf_paramAssignment_1_1() { return cThf_paramAssignment_1_1; }
		
		//Thf_atom
		public RuleCall getThf_paramThf_atomParserRuleCall_1_1_0() { return cThf_paramThf_atomParserRuleCall_1_1_0; }
		
		//(',' thf_param+=Thf_atom)*
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//','
		public Keyword getCommaKeyword_1_2_0() { return cCommaKeyword_1_2_0; }
		
		//thf_param+=Thf_atom
		public Assignment getThf_paramAssignment_1_2_1() { return cThf_paramAssignment_1_2_1; }
		
		//Thf_atom
		public RuleCall getThf_paramThf_atomParserRuleCall_1_2_1_0() { return cThf_paramThf_atomParserRuleCall_1_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}
	public class Thf_varElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Thf_var");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameUPPER_TOKENTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Thf_var:
		//	name=UPPER_TOKEN;
		@Override public ParserRule getRule() { return rule; }
		
		//name=UPPER_TOKEN
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//UPPER_TOKEN
		public RuleCall getNameUPPER_TOKENTerminalRuleCall_0() { return cNameUPPER_TOKENTerminalRuleCall_0; }
	}
	public class Thf_quantifier_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Thf_quantifier_expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cQuantifierAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cQuantifierAlternatives_0_0 = (Alternatives)cQuantifierAssignment_0.eContents().get(0);
		private final Keyword cQuantifierExclamationMarkKeyword_0_0_0 = (Keyword)cQuantifierAlternatives_0_0.eContents().get(0);
		private final Keyword cQuantifierQuestionMarkKeyword_0_0_1 = (Keyword)cQuantifierAlternatives_0_0.eContents().get(1);
		private final Keyword cQuantifierCircumflexAccentKeyword_0_0_2 = (Keyword)cQuantifierAlternatives_0_0.eContents().get(2);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParamAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParamThf_variable_listParserRuleCall_2_0 = (RuleCall)cParamAssignment_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cColonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cExpAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cExpThf_expressionParserRuleCall_5_0 = (RuleCall)cExpAssignment_5.eContents().get(0);
		
		//Thf_quantifier_expression Tff_expression:
		//	quantifier=('!' // for all
		//	| '?' //there exists
		//	| '^') '[' param=Thf_variable_list ']' ':' exp=Thf_expression;
		@Override public ParserRule getRule() { return rule; }
		
		//quantifier=('!' // for all
		//| '?' //there exists
		//| '^') '[' param=Thf_variable_list ']' ':' exp=Thf_expression
		public Group getGroup() { return cGroup; }
		
		//quantifier=('!' // for all
		//| '?' //there exists
		//| '^')
		public Assignment getQuantifierAssignment_0() { return cQuantifierAssignment_0; }
		
		//('!' // for all
		//| '?' //there exists
		//| '^')
		public Alternatives getQuantifierAlternatives_0_0() { return cQuantifierAlternatives_0_0; }
		
		//'!'
		public Keyword getQuantifierExclamationMarkKeyword_0_0_0() { return cQuantifierExclamationMarkKeyword_0_0_0; }
		
		//'?'
		public Keyword getQuantifierQuestionMarkKeyword_0_0_1() { return cQuantifierQuestionMarkKeyword_0_0_1; }
		
		//'^'
		public Keyword getQuantifierCircumflexAccentKeyword_0_0_2() { return cQuantifierCircumflexAccentKeyword_0_0_2; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }
		
		//param=Thf_variable_list
		public Assignment getParamAssignment_2() { return cParamAssignment_2; }
		
		//Thf_variable_list
		public RuleCall getParamThf_variable_listParserRuleCall_2_0() { return cParamThf_variable_listParserRuleCall_2_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
		
		//':'
		public Keyword getColonKeyword_4() { return cColonKeyword_4; }
		
		//exp=Thf_expression
		public Assignment getExpAssignment_5() { return cExpAssignment_5; }
		
		//Thf_expression
		public RuleCall getExpThf_expressionParserRuleCall_5_0() { return cExpThf_expressionParserRuleCall_5_0; }
	}
	public class Thf_variable_listElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Thf_variable_list");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cParamsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cParamsThf_var_declarationParserRuleCall_0_0 = (RuleCall)cParamsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cParamsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cParamsThf_var_declarationParserRuleCall_1_1_0 = (RuleCall)cParamsAssignment_1_1.eContents().get(0);
		
		//Thf_variable_list:
		//	params+=Thf_var_declaration (',' params+=Thf_var_declaration)*;
		@Override public ParserRule getRule() { return rule; }
		
		//params+=Thf_var_declaration (',' params+=Thf_var_declaration)*
		public Group getGroup() { return cGroup; }
		
		//params+=Thf_var_declaration
		public Assignment getParamsAssignment_0() { return cParamsAssignment_0; }
		
		//Thf_var_declaration
		public RuleCall getParamsThf_var_declarationParserRuleCall_0_0() { return cParamsThf_var_declarationParserRuleCall_0_0; }
		
		//(',' params+=Thf_var_declaration)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//params+=Thf_var_declaration
		public Assignment getParamsAssignment_1_1() { return cParamsAssignment_1_1; }
		
		//Thf_var_declaration
		public RuleCall getParamsThf_var_declarationParserRuleCall_1_1_0() { return cParamsThf_var_declarationParserRuleCall_1_1_0; }
	}
	public class Thf_var_declarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Thf_var_declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarThf_varParserRuleCall_0_0 = (RuleCall)cVarAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cVartypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVartypeThf_type_expressionParserRuleCall_2_0 = (RuleCall)cVartypeAssignment_2.eContents().get(0);
		
		//Thf_var_declaration:
		//	var=Thf_var ':' vartype=Thf_type_expression;
		@Override public ParserRule getRule() { return rule; }
		
		//var=Thf_var ':' vartype=Thf_type_expression
		public Group getGroup() { return cGroup; }
		
		//var=Thf_var
		public Assignment getVarAssignment_0() { return cVarAssignment_0; }
		
		//Thf_var
		public RuleCall getVarThf_varParserRuleCall_0_0() { return cVarThf_varParserRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//vartype=Thf_type_expression
		public Assignment getVartypeAssignment_2() { return cVartypeAssignment_2; }
		
		//Thf_type_expression
		public RuleCall getVartypeThf_type_expressionParserRuleCall_2_0() { return cVartypeThf_type_expressionParserRuleCall_2_0; }
	}
	public class Binary_operatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Binary_operator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cExclamationMarkEqualsSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cVerticalLineKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cAmpersandKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cEqualsSignGreaterThanSignKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cLessThanSignEqualsSignGreaterThanSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cLessThanSignEqualsSignKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cLessThanSignTildeGreaterThanSignKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cTildeVerticalLineKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cTildeAmpersandKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		
		////
		////thf_type_statement: type=thf_type |'('thf_type_statement')';// | left=thf_type_statement '>' right=thf_type_statement;
		////
		//////////////////////////////////////////////////////////////////////////////
		//// shared
		//Binary_operator:
		//	'!=' | '=' | '|' | '&' | '=>' | '<=>' | '<=' | '<~>' | '~|' | '~&'
		//	//The binary connectives are infix | for disjunction, 
		//	//infix & for conjunction, infix <=> for equivalence, 
		//	//infix => for implication, infix <= for reverse implication, 
		//	//infix <~> for non-equivalence (XOR), infix ~| for negated disjunction (NOR), 
		//	//infix ~& for negated conjunction (NAND), infix @ for application.
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'!=' | '=' | '|' | '&' | '=>' | '<=>' | '<=' | '<~>' | '~|' | '~&'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'!='
		public Keyword getExclamationMarkEqualsSignKeyword_0() { return cExclamationMarkEqualsSignKeyword_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }
		
		//'|'
		public Keyword getVerticalLineKeyword_2() { return cVerticalLineKeyword_2; }
		
		//'&'
		public Keyword getAmpersandKeyword_3() { return cAmpersandKeyword_3; }
		
		//'=>'
		public Keyword getEqualsSignGreaterThanSignKeyword_4() { return cEqualsSignGreaterThanSignKeyword_4; }
		
		//'<=>'
		public Keyword getLessThanSignEqualsSignGreaterThanSignKeyword_5() { return cLessThanSignEqualsSignGreaterThanSignKeyword_5; }
		
		//'<='
		public Keyword getLessThanSignEqualsSignKeyword_6() { return cLessThanSignEqualsSignKeyword_6; }
		
		//'<~>'
		public Keyword getLessThanSignTildeGreaterThanSignKeyword_7() { return cLessThanSignTildeGreaterThanSignKeyword_7; }
		
		//'~|'
		public Keyword getTildeVerticalLineKeyword_8() { return cTildeVerticalLineKeyword_8; }
		
		//'~&'
		public Keyword getTildeAmpersandKeyword_9() { return cTildeAmpersandKeyword_9; }
	}
	public class Lower_token_and_keywordElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.Lower_token_and_keyword");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAxiomKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cHypothesisKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cNegated_conjectureKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cConjectureKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cDefinitionKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cLemmaKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cTypeKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cPlainKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final RuleCall cLOWER_TOKENTerminalRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		
		//Lower_token_and_keyword: //this repitition is for autocomplete
		//	'axiom' | 'hypothesis' | 'negated_conjecture' | 'conjecture' | 'definition' | 'lemma' | 'type' | 'plain' | LOWER_TOKEN;
		@Override public ParserRule getRule() { return rule; }
		
		////this repitition is for autocomplete
		//'axiom' | 'hypothesis' | 'negated_conjecture' | 'conjecture' | 'definition' | 'lemma' | 'type' | 'plain' | LOWER_TOKEN
		public Alternatives getAlternatives() { return cAlternatives; }
		
		////this repitition is for autocomplete
		//'axiom'
		public Keyword getAxiomKeyword_0() { return cAxiomKeyword_0; }
		
		//'hypothesis'
		public Keyword getHypothesisKeyword_1() { return cHypothesisKeyword_1; }
		
		//'negated_conjecture'
		public Keyword getNegated_conjectureKeyword_2() { return cNegated_conjectureKeyword_2; }
		
		//'conjecture'
		public Keyword getConjectureKeyword_3() { return cConjectureKeyword_3; }
		
		//'definition'
		public Keyword getDefinitionKeyword_4() { return cDefinitionKeyword_4; }
		
		//'lemma'
		public Keyword getLemmaKeyword_5() { return cLemmaKeyword_5; }
		
		//'type'
		public Keyword getTypeKeyword_6() { return cTypeKeyword_6; }
		
		//'plain'
		public Keyword getPlainKeyword_7() { return cPlainKeyword_7; }
		
		//LOWER_TOKEN
		public RuleCall getLOWER_TOKENTerminalRuleCall_8() { return cLOWER_TOKENTerminalRuleCall_8; }
	}
	
	
	private final ModelElements pModel;
	private final IncludeElements pInclude;
	private final Fof_inputElements pFof_input;
	private final Fof_rootElements pFof_root;
	private final Fof_expressionElements pFof_expression;
	private final Fof_terminating_expressionElements pFof_terminating_expression;
	private final Fof_atomElements pFof_atom;
	private final Fof_atom_literalElements pFof_atom_literal;
	private final Fof_constantElements pFof_constant;
	private final Fof_varElements pFof_var;
	private final Fof_quantifier_expressionElements pFof_quantifier_expression;
	private final Fof_variable_listElements pFof_variable_list;
	private final Tff_inputElements pTff_input;
	private final Tff_rootElements pTff_root;
	private final Tff_formula_type_definitionElements pTff_formula_type_definition;
	private final Tff_type_expressionElements pTff_type_expression;
	private final Tff_terminal_type_expressionElements pTff_terminal_type_expression;
	private final Tff_type_atomElements pTff_type_atom;
	private final Tff_type_constantElements pTff_type_constant;
	private final Tff_type_literalElements pTff_type_literal;
	private final Tff_expressionElements pTff_expression;
	private final Tff_terminating_expressionElements pTff_terminating_expression;
	private final Tff_atomElements pTff_atom;
	private final Tff_constantElements pTff_constant;
	private final Tff_atom_literalElements pTff_atom_literal;
	private final Tff_predefined_function_1_argsElements pTff_predefined_function_1_args;
	private final Tff_predefined_function_2_argsElements pTff_predefined_function_2_args;
	private final Tff_varElements pTff_var;
	private final Tff_var_declarationElements pTff_var_declaration;
	private final Tff_quantifier_expressionElements pTff_quantifier_expression;
	private final Tff_type_quantifier_epressionElements pTff_type_quantifier_epression;
	private final Tff_variable_listElements pTff_variable_list;
	private final Cnf_inputElements pCnf_input;
	private final Cnf_rootElements pCnf_root;
	private final Cnf_formula_type_definitionElements pCnf_formula_type_definition;
	private final Cnf_orElements pCnf_or;
	private final Cnf_notElements pCnf_not;
	private final Cnf_equalityElements pCnf_equality;
	private final Cnf_expressionElements pCnf_expression;
	private final Cnf_constantElements pCnf_constant;
	private final Cnf_varElements pCnf_var;
	private final Cnf_statement_literalElements pCnf_statement_literal;
	private final Thf_inputElements pThf_input;
	private final Thf_rootElements pThf_root;
	private final Thf_formula_type_definitionElements pThf_formula_type_definition;
	private final Thf_type_expressionElements pThf_type_expression;
	private final Thf_terminal_type_expressionElements pThf_terminal_type_expression;
	private final Thf_type_atomElements pThf_type_atom;
	private final Thf_type_constantElements pThf_type_constant;
	private final Thf_type_literalElements pThf_type_literal;
	private final Thf_expressionElements pThf_expression;
	private final Thf_terminating_expressionElements pThf_terminating_expression;
	private final Thf_unary_operatorElements pThf_unary_operator;
	private final Thf_binary_operatorElements pThf_binary_operator;
	private final Thf_atomElements pThf_atom;
	private final Thf_atom_literalElements pThf_atom_literal;
	private final Thf_constantElements pThf_constant;
	private final Thf_varElements pThf_var;
	private final Thf_quantifier_expressionElements pThf_quantifier_expression;
	private final Thf_variable_listElements pThf_variable_list;
	private final Thf_var_declarationElements pThf_var_declaration;
	private final Binary_operatorElements pBinary_operator;
	private final Lower_token_and_keywordElements pLower_token_and_keyword;
	private final TerminalRule tLOWER_TOKEN;
	private final TerminalRule tUPPER_TOKEN;
	private final TerminalRule tSTRING;
	private final TerminalRule tML_COMMENT;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tWS;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public TPTPGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pModel = new ModelElements();
		this.pInclude = new IncludeElements();
		this.pFof_input = new Fof_inputElements();
		this.pFof_root = new Fof_rootElements();
		this.pFof_expression = new Fof_expressionElements();
		this.pFof_terminating_expression = new Fof_terminating_expressionElements();
		this.pFof_atom = new Fof_atomElements();
		this.pFof_atom_literal = new Fof_atom_literalElements();
		this.pFof_constant = new Fof_constantElements();
		this.pFof_var = new Fof_varElements();
		this.pFof_quantifier_expression = new Fof_quantifier_expressionElements();
		this.pFof_variable_list = new Fof_variable_listElements();
		this.pTff_input = new Tff_inputElements();
		this.pTff_root = new Tff_rootElements();
		this.pTff_formula_type_definition = new Tff_formula_type_definitionElements();
		this.pTff_type_expression = new Tff_type_expressionElements();
		this.pTff_terminal_type_expression = new Tff_terminal_type_expressionElements();
		this.pTff_type_atom = new Tff_type_atomElements();
		this.pTff_type_constant = new Tff_type_constantElements();
		this.pTff_type_literal = new Tff_type_literalElements();
		this.pTff_expression = new Tff_expressionElements();
		this.pTff_terminating_expression = new Tff_terminating_expressionElements();
		this.pTff_atom = new Tff_atomElements();
		this.pTff_constant = new Tff_constantElements();
		this.pTff_atom_literal = new Tff_atom_literalElements();
		this.pTff_predefined_function_1_args = new Tff_predefined_function_1_argsElements();
		this.pTff_predefined_function_2_args = new Tff_predefined_function_2_argsElements();
		this.pTff_var = new Tff_varElements();
		this.pTff_var_declaration = new Tff_var_declarationElements();
		this.pTff_quantifier_expression = new Tff_quantifier_expressionElements();
		this.pTff_type_quantifier_epression = new Tff_type_quantifier_epressionElements();
		this.pTff_variable_list = new Tff_variable_listElements();
		this.pCnf_input = new Cnf_inputElements();
		this.pCnf_root = new Cnf_rootElements();
		this.pCnf_formula_type_definition = new Cnf_formula_type_definitionElements();
		this.pCnf_or = new Cnf_orElements();
		this.pCnf_not = new Cnf_notElements();
		this.pCnf_equality = new Cnf_equalityElements();
		this.pCnf_expression = new Cnf_expressionElements();
		this.pCnf_constant = new Cnf_constantElements();
		this.pCnf_var = new Cnf_varElements();
		this.pCnf_statement_literal = new Cnf_statement_literalElements();
		this.pThf_input = new Thf_inputElements();
		this.pThf_root = new Thf_rootElements();
		this.pThf_formula_type_definition = new Thf_formula_type_definitionElements();
		this.pThf_type_expression = new Thf_type_expressionElements();
		this.pThf_terminal_type_expression = new Thf_terminal_type_expressionElements();
		this.pThf_type_atom = new Thf_type_atomElements();
		this.pThf_type_constant = new Thf_type_constantElements();
		this.pThf_type_literal = new Thf_type_literalElements();
		this.pThf_expression = new Thf_expressionElements();
		this.pThf_terminating_expression = new Thf_terminating_expressionElements();
		this.pThf_unary_operator = new Thf_unary_operatorElements();
		this.pThf_binary_operator = new Thf_binary_operatorElements();
		this.pThf_atom = new Thf_atomElements();
		this.pThf_atom_literal = new Thf_atom_literalElements();
		this.pThf_constant = new Thf_constantElements();
		this.pThf_var = new Thf_varElements();
		this.pThf_quantifier_expression = new Thf_quantifier_expressionElements();
		this.pThf_variable_list = new Thf_variable_listElements();
		this.pThf_var_declaration = new Thf_var_declarationElements();
		this.pBinary_operator = new Binary_operatorElements();
		this.pLower_token_and_keyword = new Lower_token_and_keywordElements();
		this.tLOWER_TOKEN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.LOWER_TOKEN");
		this.tUPPER_TOKEN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.UPPER_TOKEN");
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.STRING");
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.ML_COMMENT");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.SL_COMMENT");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "it.unibz.inf.tptp.TPTP.WS");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("it.unibz.inf.tptp.TPTP".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	////grammar com.theoremsandstuff.tptp.Parser hidden(WS, ML_COMMENT, SL_COMMENT)
	////
	////import "http://www.eclipse.org/emf/2002/Ecore" as ecore
	////generate parser "http://www.theoremsandstuff.com/tptp/Parser"
	////generate parser "http://www.unibz.it/inf/"
	//Model:
	//	TPTP_input+=Include* (TPTP_input+=Fof_input* | TPTP_input+=Tff_input* | TPTP_input+=Cnf_input* |
	//	TPTP_input+=Thf_input*);
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	//Include:
	//	'include' '(' path=STRING ')' '.';
	public IncludeElements getIncludeAccess() {
		return pInclude;
	}
	
	public ParserRule getIncludeRule() {
		return getIncludeAccess().getRule();
	}
	
	//Fof_input:
	//	Fof_root | Include;
	public Fof_inputElements getFof_inputAccess() {
		return pFof_input;
	}
	
	public ParserRule getFof_inputRule() {
		return getFof_inputAccess().getRule();
	}
	
	//Fof_root:
	//	'fof' '('
	//	name=(Lower_token_and_keyword | STRING)
	//	',' formula_role=('axiom' | 'hypothesis' | 'negated_conjecture'
	//	| 'conjecture' | 'definition' | 'lemma')
	//	',' exp=Fof_expression
	//	')' '.';
	public Fof_rootElements getFof_rootAccess() {
		return pFof_root;
	}
	
	public ParserRule getFof_rootRule() {
		return getFof_rootAccess().getRule();
	}
	
	//Fof_expression:
	//	Fof_terminating_expression ({binary.left=current} op=Binary_operator right=Fof_terminating_expression)*;
	public Fof_expressionElements getFof_expressionAccess() {
		return pFof_expression;
	}
	
	public ParserRule getFof_expressionRule() {
		return getFof_expressionAccess().getRule();
	}
	
	//Fof_terminating_expression Fof_expression:
	//	fof_atom=Fof_atom |
	//	'(' Fof_expression ')' | fof_negation?='~' fof_exp=Fof_expression | fof_exp=Fof_quantifier_expression;
	public Fof_terminating_expressionElements getFof_terminating_expressionAccess() {
		return pFof_terminating_expression;
	}
	
	public ParserRule getFof_terminating_expressionRule() {
		return getFof_terminating_expressionAccess().getRule();
	}
	
	//Fof_atom:
	//	Fof_constant | Fof_var | Fof_atom_literal;
	public Fof_atomElements getFof_atomAccess() {
		return pFof_atom;
	}
	
	public ParserRule getFof_atomRule() {
		return getFof_atomAccess().getRule();
	}
	
	//Fof_atom_literal Fof_constant:
	//	name=('$true' | '$false');
	public Fof_atom_literalElements getFof_atom_literalAccess() {
		return pFof_atom_literal;
	}
	
	public ParserRule getFof_atom_literalRule() {
		return getFof_atom_literalAccess().getRule();
	}
	
	//Fof_constant:
	//	name=(Lower_token_and_keyword | STRING) ('(' fof_param+=Fof_atom (',' fof_param+=Fof_atom)* ')')?;
	public Fof_constantElements getFof_constantAccess() {
		return pFof_constant;
	}
	
	public ParserRule getFof_constantRule() {
		return getFof_constantAccess().getRule();
	}
	
	//Fof_var:
	//	name=UPPER_TOKEN;
	public Fof_varElements getFof_varAccess() {
		return pFof_var;
	}
	
	public ParserRule getFof_varRule() {
		return getFof_varAccess().getRule();
	}
	
	//Fof_quantifier_expression Fof_expression:
	//	fof_quantifier=('!' // for all
	//	| '?' //there exists
	//) '[' fof_param=Fof_variable_list ']' ':' fof_exp=Fof_expression;
	public Fof_quantifier_expressionElements getFof_quantifier_expressionAccess() {
		return pFof_quantifier_expression;
	}
	
	public ParserRule getFof_quantifier_expressionRule() {
		return getFof_quantifier_expressionAccess().getRule();
	}
	
	//Fof_variable_list:
	//	params+=Fof_var (',' params+=Fof_var)*;
	public Fof_variable_listElements getFof_variable_listAccess() {
		return pFof_variable_list;
	}
	
	public ParserRule getFof_variable_listRule() {
		return getFof_variable_listAccess().getRule();
	}
	
	//////////////////////////////////////////////////////////////////////////////
	//// TFF
	//Tff_input:
	//	Tff_root | Include;
	public Tff_inputElements getTff_inputAccess() {
		return pTff_input;
	}
	
	public ParserRule getTff_inputRule() {
		return getTff_inputAccess().getRule();
	}
	
	//Tff_root:
	//	'tff' '(' name=(Lower_token_and_keyword | STRING)
	//	',' formula_role=('axiom' | 'hypothesis' | 'negated_conjecture' | 'conjecture' | 'definition' | 'lemma')
	//	',' exp=Tff_expression
	//	')' '.' | 'tff' '(' name=(Lower_token_and_keyword | STRING)
	//	',' formula_role='type' ',' def=Tff_formula_type_definition
	//	')' '.';
	public Tff_rootElements getTff_rootAccess() {
		return pTff_root;
	}
	
	public ParserRule getTff_rootRule() {
		return getTff_rootAccess().getRule();
	}
	
	//Tff_formula_type_definition:
	//	'(' Tff_formula_type_definition ')' | (name=Lower_token_and_keyword | name=STRING) ':'
	//	exp=(Tff_type_quantifier_epression | Tff_type_expression);
	public Tff_formula_type_definitionElements getTff_formula_type_definitionAccess() {
		return pTff_formula_type_definition;
	}
	
	public ParserRule getTff_formula_type_definitionRule() {
		return getTff_formula_type_definitionAccess().getRule();
	}
	
	////these operators are left associative, as god intended
	////TODO: should we AST modle these as Tff_type_constant with 2 params?
	//Tff_type_expression:
	//	Tff_terminal_type_expression ({oper.left=current} op=('>' | '*') right+=Tff_terminal_type_expression)*;
	public Tff_type_expressionElements getTff_type_expressionAccess() {
		return pTff_type_expression;
	}
	
	public ParserRule getTff_type_expressionRule() {
		return getTff_type_expressionAccess().getRule();
	}
	
	//Tff_terminal_type_expression Tff_type_expression:
	//	Tff_type_atom | '(' Tff_type_expression ')';
	public Tff_terminal_type_expressionElements getTff_terminal_type_expressionAccess() {
		return pTff_terminal_type_expression;
	}
	
	public ParserRule getTff_terminal_type_expressionRule() {
		return getTff_terminal_type_expressionAccess().getRule();
	}
	
	//Tff_type_atom:
	//	Tff_type_constant | Tff_var | Tff_type_literal;
	public Tff_type_atomElements getTff_type_atomAccess() {
		return pTff_type_atom;
	}
	
	public ParserRule getTff_type_atomRule() {
		return getTff_type_atomAccess().getRule();
	}
	
	//Tff_type_constant:
	//	name=(Lower_token_and_keyword | STRING) ('(' param+=Tff_type_atom (',' param+=Tff_type_atom)* ')')?;
	public Tff_type_constantElements getTff_type_constantAccess() {
		return pTff_type_constant;
	}
	
	public ParserRule getTff_type_constantRule() {
		return getTff_type_constantAccess().getRule();
	}
	
	////TODO: don't support edgecase:
	////tff(sorted_type,type,(
	////    sorted: "$i" )).
	//Tff_type_literal Tff_type_constant:
	//	name=('$i' | '$o' | '$tType' | '$int' | '$real' | '$rat');
	public Tff_type_literalElements getTff_type_literalAccess() {
		return pTff_type_literal;
	}
	
	public ParserRule getTff_type_literalRule() {
		return getTff_type_literalAccess().getRule();
	}
	
	//Tff_expression:
	//	Tff_terminating_expression ({binary.left=current} op=Binary_operator right=Tff_terminating_expression)*;
	public Tff_expressionElements getTff_expressionAccess() {
		return pTff_expression;
	}
	
	public ParserRule getTff_expressionRule() {
		return getTff_expressionAccess().getRule();
	}
	
	//Tff_terminating_expression Tff_expression:
	//	atom=Tff_atom |
	//	'(' Tff_expression ')' | negation?='~' exp=Tff_expression | exp=Tff_quantifier_expression;
	public Tff_terminating_expressionElements getTff_terminating_expressionAccess() {
		return pTff_terminating_expression;
	}
	
	public ParserRule getTff_terminating_expressionRule() {
		return getTff_terminating_expressionAccess().getRule();
	}
	
	//Tff_atom:
	//	Tff_var | Tff_atom_literal | Tff_constant | Tff_predefined_function_1_args | Tff_predefined_function_2_args;
	public Tff_atomElements getTff_atomAccess() {
		return pTff_atom;
	}
	
	public ParserRule getTff_atomRule() {
		return getTff_atomAccess().getRule();
	}
	
	//Tff_constant:
	//	name=(Lower_token_and_keyword | STRING) ('(' param+=Tff_atom (',' param+=Tff_atom)* ')')? |
	//	top=Lower_token_and_keyword name='/' bottom=Lower_token_and_keyword;
	public Tff_constantElements getTff_constantAccess() {
		return pTff_constant;
	}
	
	public ParserRule getTff_constantRule() {
		return getTff_constantAccess().getRule();
	}
	
	//Tff_atom_literal Tff_constant:
	//	name=('$true' |
	//	'$false');
	public Tff_atom_literalElements getTff_atom_literalAccess() {
		return pTff_atom_literal;
	}
	
	public ParserRule getTff_atom_literalRule() {
		return getTff_atom_literalAccess().getRule();
	}
	
	//Tff_predefined_function_1_args Tff_constant:
	//	name=('$is_int' | '$is_rat' //ANYTHING -> BOOL
	//	| '$uminus' // NUM -> NUM ?
	//	| '$to_int' //ANYTHING? -> INT
	//	| '$to_rat' //ANYTHING? -> RAT
	//	| '$to_real' //ANYTHING? -> REAL
	//)
	//	'(' param+=Tff_expression ')';
	public Tff_predefined_function_1_argsElements getTff_predefined_function_1_argsAccess() {
		return pTff_predefined_function_1_args;
	}
	
	public ParserRule getTff_predefined_function_1_argsRule() {
		return getTff_predefined_function_1_argsAccess().getRule();
	}
	
	////TODO: make this returns Tff_constant:
	////TODO: change func to name
	////TODO: possibly file a bug
	//Tff_predefined_function_2_args:
	//	func=('$less' | '$sum' | '$difference' | '$product' | '$quotient' | '$quotient_e' | '$quotient_t' | '$quotient_f' |
	//	'$remainder_e' | '$remainder_t' | '$remainder_f' | '$greatereq' | '$lesseq' | '$greater' | '$eq'
	//	//also $distinct
	//) '(' param+=Tff_expression ',' param+=Tff_expression ')';
	public Tff_predefined_function_2_argsElements getTff_predefined_function_2_argsAccess() {
		return pTff_predefined_function_2_args;
	}
	
	public ParserRule getTff_predefined_function_2_argsRule() {
		return getTff_predefined_function_2_argsAccess().getRule();
	}
	
	//Tff_var:
	//	name=UPPER_TOKEN;
	public Tff_varElements getTff_varAccess() {
		return pTff_var;
	}
	
	public ParserRule getTff_varRule() {
		return getTff_varAccess().getRule();
	}
	
	//Tff_var_declaration:
	//	var=Tff_var ':' vartype=Tff_type_expression;
	public Tff_var_declarationElements getTff_var_declarationAccess() {
		return pTff_var_declaration;
	}
	
	public ParserRule getTff_var_declarationRule() {
		return getTff_var_declarationAccess().getRule();
	}
	
	//Tff_quantifier_expression Tff_expression:
	//	quantifier=('!' // for all
	//	| '?' //there exists
	//) '[' param=Tff_variable_list ']' ':' exp=Tff_expression;
	public Tff_quantifier_expressionElements getTff_quantifier_expressionAccess() {
		return pTff_quantifier_expression;
	}
	
	public ParserRule getTff_quantifier_expressionRule() {
		return getTff_quantifier_expressionAccess().getRule();
	}
	
	//Tff_type_quantifier_epression Tff_expression:
	//	quantifier='!>' //????
	//	'[' param=Tff_variable_list ']' ':' exp=Tff_type_expression;
	public Tff_type_quantifier_epressionElements getTff_type_quantifier_epressionAccess() {
		return pTff_type_quantifier_epression;
	}
	
	public ParserRule getTff_type_quantifier_epressionRule() {
		return getTff_type_quantifier_epressionAccess().getRule();
	}
	
	////TODO: the syntax colisions here are insane! what does ":" mean?
	//Tff_variable_list:
	//	params+=Tff_var_declaration (',' params+=Tff_var_declaration)*;
	public Tff_variable_listElements getTff_variable_listAccess() {
		return pTff_variable_list;
	}
	
	public ParserRule getTff_variable_listRule() {
		return getTff_variable_listAccess().getRule();
	}
	
	////////////////////////////////////////////////////////////////////////////////////
	//// CNF
	//Cnf_input:
	//	Cnf_root | Include;
	public Cnf_inputElements getCnf_inputAccess() {
		return pCnf_input;
	}
	
	public ParserRule getCnf_inputRule() {
		return getCnf_inputAccess().getRule();
	}
	
	//Cnf_root:
	//	'cnf' '(' name=(Lower_token_and_keyword | STRING)
	//	',' formula_role=('axiom' | 'hypothesis' | 'negated_conjecture' |
	//	'plain' //TODO: check if this has been depricated
	//)
	//	',' exp=Cnf_formula_type_definition
	//	')' '.';
	public Cnf_rootElements getCnf_rootAccess() {
		return pCnf_root;
	}
	
	public ParserRule getCnf_rootRule() {
		return getCnf_rootAccess().getRule();
	}
	
	//Cnf_formula_type_definition:
	//	'(' disjunction=Cnf_or ')' | disjunction=Cnf_or;
	public Cnf_formula_type_definitionElements getCnf_formula_type_definitionAccess() {
		return pCnf_formula_type_definition;
	}
	
	public ParserRule getCnf_formula_type_definitionRule() {
		return getCnf_formula_type_definitionAccess().getRule();
	}
	
	//Cnf_or:
	//	or+=Cnf_not ('|' or+=Cnf_not)*;
	public Cnf_orElements getCnf_orAccess() {
		return pCnf_or;
	}
	
	public ParserRule getCnf_orRule() {
		return getCnf_orAccess().getRule();
	}
	
	//Cnf_not:
	//	negated?='~'? literal=Cnf_equality;
	public Cnf_notElements getCnf_notAccess() {
		return pCnf_not;
	}
	
	public ParserRule getCnf_notRule() {
		return getCnf_notAccess().getRule();
	}
	
	////TODO: cange nagated to something that is true when the formula is true and false otherwise
	////TODO: merge down
	//Cnf_equality:
	//	expL=Cnf_expression (eq=('=' | '!=') expR=Cnf_expression)?;
	public Cnf_equalityElements getCnf_equalityAccess() {
		return pCnf_equality;
	}
	
	public ParserRule getCnf_equalityRule() {
		return getCnf_equalityAccess().getRule();
	}
	
	////TODO: file bug report:
	////cnf_not:
	////        ('~')? (cnf_exp | cnf_equality);
	////
	////cnf_equality: cnf_exp '=' cnf_exp;
	//Cnf_expression:
	//	Cnf_constant | Cnf_var | cnf_exp=Cnf_statement_literal;
	public Cnf_expressionElements getCnf_expressionAccess() {
		return pCnf_expression;
	}
	
	public ParserRule getCnf_expressionRule() {
		return getCnf_expressionAccess().getRule();
	}
	
	//Cnf_constant:
	//	name=(Lower_token_and_keyword | STRING) ('(' param+=Cnf_expression (',' param+=Cnf_expression)* ')')?;
	public Cnf_constantElements getCnf_constantAccess() {
		return pCnf_constant;
	}
	
	public ParserRule getCnf_constantRule() {
		return getCnf_constantAccess().getRule();
	}
	
	//Cnf_var:
	//	name=UPPER_TOKEN;
	public Cnf_varElements getCnf_varAccess() {
		return pCnf_var;
	}
	
	public ParserRule getCnf_varRule() {
		return getCnf_varAccess().getRule();
	}
	
	////TODO: tooltip doc
	////TODO: make more DRY
	//Cnf_statement_literal:
	//	'$true' | '$false';
	public Cnf_statement_literalElements getCnf_statement_literalAccess() {
		return pCnf_statement_literal;
	}
	
	public ParserRule getCnf_statement_literalRule() {
		return getCnf_statement_literalAccess().getRule();
	}
	
	////TODO: compile time type checking would be super cool
	////TODO: should only be able to import file of the same language
	////TODO: import magic
	///////////////////////////////////////////////////////////////////////////
	//// THF
	//Thf_input:
	//	Thf_root | Include;
	public Thf_inputElements getThf_inputAccess() {
		return pThf_input;
	}
	
	public ParserRule getThf_inputRule() {
		return getThf_inputAccess().getRule();
	}
	
	//Thf_root:
	//	'thf' '(' name=(Lower_token_and_keyword | STRING)
	//	',' formula_role='type'
	//	',' def=Thf_formula_type_definition
	//	')' '.'
	//	|
	//	'thf' '(' name=(Lower_token_and_keyword | STRING)
	//	',' formula_role=('axiom' | 'hypothesis' | 'negated_conjecture' | 'conjecture' | 'definition' | 'lemma')
	//	',' thf_exp=Thf_expression
	//	')' '.';
	public Thf_rootElements getThf_rootAccess() {
		return pThf_root;
	}
	
	public ParserRule getThf_rootRule() {
		return getThf_rootAccess().getRule();
	}
	
	//Thf_formula_type_definition:
	//	'(' Thf_formula_type_definition ')' | name=(Lower_token_and_keyword | STRING) ':' exp=Thf_type_expression;
	public Thf_formula_type_definitionElements getThf_formula_type_definitionAccess() {
		return pThf_formula_type_definition;
	}
	
	public ParserRule getThf_formula_type_definitionRule() {
		return getThf_formula_type_definitionAccess().getRule();
	}
	
	////these operators are left associative, as god intended
	////TODO: should we AST modle these as Tff_type_constant with 2 params?
	//Thf_type_expression:
	//	Thf_terminal_type_expression ({oper.left=current} op='>' right+=Thf_terminal_type_expression)*;
	public Thf_type_expressionElements getThf_type_expressionAccess() {
		return pThf_type_expression;
	}
	
	public ParserRule getThf_type_expressionRule() {
		return getThf_type_expressionAccess().getRule();
	}
	
	//Thf_terminal_type_expression Thf_type_expression:
	//	Thf_type_atom
	//	| '(' Thf_type_expression ')';
	public Thf_terminal_type_expressionElements getThf_terminal_type_expressionAccess() {
		return pThf_terminal_type_expression;
	}
	
	public ParserRule getThf_terminal_type_expressionRule() {
		return getThf_terminal_type_expressionAccess().getRule();
	}
	
	//Thf_type_atom:
	//	Thf_type_constant | Thf_type_literal;
	public Thf_type_atomElements getThf_type_atomAccess() {
		return pThf_type_atom;
	}
	
	public ParserRule getThf_type_atomRule() {
		return getThf_type_atomAccess().getRule();
	}
	
	//Thf_type_constant:
	//	name=(Lower_token_and_keyword | STRING);
	public Thf_type_constantElements getThf_type_constantAccess() {
		return pThf_type_constant;
	}
	
	public ParserRule getThf_type_constantRule() {
		return getThf_type_constantAccess().getRule();
	}
	
	////('(' param+=tff_type_atom (',' param+=tff_type_atom)* ')')?;
	//Thf_type_literal Thf_type_constant:
	//	name=('$i' | '$o' | '$tType');
	public Thf_type_literalElements getThf_type_literalAccess() {
		return pThf_type_literal;
	}
	
	public ParserRule getThf_type_literalRule() {
		return getThf_type_literalAccess().getRule();
	}
	
	////type=[thf_formula_type_definition]
	//Thf_expression:
	//	Thf_terminating_expression ({binary.left=current} op=Thf_binary_operator right=Thf_terminating_expression)*;
	public Thf_expressionElements getThf_expressionAccess() {
		return pThf_expression;
	}
	
	public ParserRule getThf_expressionRule() {
		return getThf_expressionAccess().getRule();
	}
	
	//Thf_terminating_expression Thf_expression:
	//	thf_atom=Thf_atom |
	//	'(' Thf_expression ')' | thf_negation?='~' thf_exp=Thf_expression | op=Thf_unary_operator thf_exp=Thf_expression |
	//	thf_exp=Thf_quantifier_expression;
	public Thf_terminating_expressionElements getThf_terminating_expressionAccess() {
		return pThf_terminating_expression;
	}
	
	public ParserRule getThf_terminating_expressionRule() {
		return getThf_terminating_expressionAccess().getRule();
	}
	
	////I don't know what the fuck any of these do
	//Thf_unary_operator:
	//	'@' | '??' | '!!' | '&' | '|' | '=>';
	public Thf_unary_operatorElements getThf_unary_operatorAccess() {
		return pThf_unary_operator;
	}
	
	public ParserRule getThf_unary_operatorRule() {
		return getThf_unary_operatorAccess().getRule();
	}
	
	//Thf_binary_operator:
	//	'&' | '=>' | '|'
	//	| '@' // (denoting apply) is left-associative and lambda is right-associative. //TODO: deal with asocativity crap
	//	//^ [X] : ^ [Y] : f @ g (where f is a <thf_apply_formula> and g is a
	//	//<thf_unitary_formula>) should be parsed as: (^ [X] : (^ [Y] : f)) @ g.
	//	//That is, g is not in the scope of either lambda.
	//	| '=' //TODO: how is this actualy defined?
	//	| '!='
	//	| '<='
	//	| '<=>'
	//	| '<~>';
	public Thf_binary_operatorElements getThf_binary_operatorAccess() {
		return pThf_binary_operator;
	}
	
	public ParserRule getThf_binary_operatorRule() {
		return getThf_binary_operatorAccess().getRule();
	}
	
	//Thf_atom:
	//	Thf_constant | Thf_var | Thf_atom_literal;
	public Thf_atomElements getThf_atomAccess() {
		return pThf_atom;
	}
	
	public ParserRule getThf_atomRule() {
		return getThf_atomAccess().getRule();
	}
	
	//Thf_atom_literal Thf_constant:
	//	name=('$true' |
	//	'$false');
	public Thf_atom_literalElements getThf_atom_literalAccess() {
		return pThf_atom_literal;
	}
	
	public ParserRule getThf_atom_literalRule() {
		return getThf_atom_literalAccess().getRule();
	}
	
	//Thf_constant:
	//	name=(Lower_token_and_keyword | STRING) ('(' thf_param+=Thf_atom (',' thf_param+=Thf_atom)* ')')?;
	public Thf_constantElements getThf_constantAccess() {
		return pThf_constant;
	}
	
	public ParserRule getThf_constantRule() {
		return getThf_constantAccess().getRule();
	}
	
	//Thf_var:
	//	name=UPPER_TOKEN;
	public Thf_varElements getThf_varAccess() {
		return pThf_var;
	}
	
	public ParserRule getThf_varRule() {
		return getThf_varAccess().getRule();
	}
	
	//Thf_quantifier_expression Tff_expression:
	//	quantifier=('!' // for all
	//	| '?' //there exists
	//	| '^') '[' param=Thf_variable_list ']' ':' exp=Thf_expression;
	public Thf_quantifier_expressionElements getThf_quantifier_expressionAccess() {
		return pThf_quantifier_expression;
	}
	
	public ParserRule getThf_quantifier_expressionRule() {
		return getThf_quantifier_expressionAccess().getRule();
	}
	
	//Thf_variable_list:
	//	params+=Thf_var_declaration (',' params+=Thf_var_declaration)*;
	public Thf_variable_listElements getThf_variable_listAccess() {
		return pThf_variable_list;
	}
	
	public ParserRule getThf_variable_listRule() {
		return getThf_variable_listAccess().getRule();
	}
	
	//Thf_var_declaration:
	//	var=Thf_var ':' vartype=Thf_type_expression;
	public Thf_var_declarationElements getThf_var_declarationAccess() {
		return pThf_var_declaration;
	}
	
	public ParserRule getThf_var_declarationRule() {
		return getThf_var_declarationAccess().getRule();
	}
	
	////
	////thf_type_statement: type=thf_type |'('thf_type_statement')';// | left=thf_type_statement '>' right=thf_type_statement;
	////
	//////////////////////////////////////////////////////////////////////////////
	//// shared
	//Binary_operator:
	//	'!=' | '=' | '|' | '&' | '=>' | '<=>' | '<=' | '<~>' | '~|' | '~&'
	//	//The binary connectives are infix | for disjunction, 
	//	//infix & for conjunction, infix <=> for equivalence, 
	//	//infix => for implication, infix <= for reverse implication, 
	//	//infix <~> for non-equivalence (XOR), infix ~| for negated disjunction (NOR), 
	//	//infix ~& for negated conjunction (NAND), infix @ for application.
	//;
	public Binary_operatorElements getBinary_operatorAccess() {
		return pBinary_operator;
	}
	
	public ParserRule getBinary_operatorRule() {
		return getBinary_operatorAccess().getRule();
	}
	
	//Lower_token_and_keyword: //this repitition is for autocomplete
	//	'axiom' | 'hypothesis' | 'negated_conjecture' | 'conjecture' | 'definition' | 'lemma' | 'type' | 'plain' | LOWER_TOKEN;
	public Lower_token_and_keywordElements getLower_token_and_keywordAccess() {
		return pLower_token_and_keyword;
	}
	
	public ParserRule getLower_token_and_keywordRule() {
		return getLower_token_and_keywordAccess().getRule();
	}
	
	//terminal LOWER_TOKEN:
	//	('a'..'z' | '_' | '-' | '.' | '0'..'9') ('a'..'z' | 'A'..'Z' | '_' | '-' | '.' | '0'..'9')*;
	public TerminalRule getLOWER_TOKENRule() {
		return tLOWER_TOKEN;
	}
	
	//terminal UPPER_TOKEN:
	//	'A'..'Z' ('a'..'z' | 'A'..'Z' | '_' | '-' | '.' | '0'..'9')*;
	public TerminalRule getUPPER_TOKENRule() {
		return tUPPER_TOKEN;
	}
	
	//@ Override terminal STRING:
	//	'"' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | "'" | '\\') | !('\\' | '"'))* '"' |
	//	"'" ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | "'" | '\\') | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	}
	
	//@ Override terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	}
	
	//@ Override terminal SL_COMMENT:
	//	'%' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	}
	
	//@ Override terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return tWS;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
