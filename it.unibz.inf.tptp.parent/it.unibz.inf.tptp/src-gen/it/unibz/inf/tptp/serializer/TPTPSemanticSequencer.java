/*
 * generated by Xtext 2.12.0
 */
package it.unibz.inf.tptp.serializer;

import com.google.inject.Inject;
import it.unibz.inf.tptp.parser.Cnf_constant;
import it.unibz.inf.tptp.parser.Cnf_equality;
import it.unibz.inf.tptp.parser.Cnf_expression;
import it.unibz.inf.tptp.parser.Cnf_formula_type_definition;
import it.unibz.inf.tptp.parser.Cnf_not;
import it.unibz.inf.tptp.parser.Cnf_or;
import it.unibz.inf.tptp.parser.Cnf_root;
import it.unibz.inf.tptp.parser.Cnf_var;
import it.unibz.inf.tptp.parser.Fof_constant;
import it.unibz.inf.tptp.parser.Fof_expression;
import it.unibz.inf.tptp.parser.Fof_root;
import it.unibz.inf.tptp.parser.Fof_var;
import it.unibz.inf.tptp.parser.Fof_variable_list;
import it.unibz.inf.tptp.parser.Include;
import it.unibz.inf.tptp.parser.Model;
import it.unibz.inf.tptp.parser.ParserPackage;
import it.unibz.inf.tptp.parser.Tff_constant;
import it.unibz.inf.tptp.parser.Tff_expression;
import it.unibz.inf.tptp.parser.Tff_formula_type_definition;
import it.unibz.inf.tptp.parser.Tff_predefined_function_2_args;
import it.unibz.inf.tptp.parser.Tff_root;
import it.unibz.inf.tptp.parser.Tff_type_constant;
import it.unibz.inf.tptp.parser.Tff_var;
import it.unibz.inf.tptp.parser.Tff_var_declaration;
import it.unibz.inf.tptp.parser.Tff_variable_list;
import it.unibz.inf.tptp.parser.Thf_constant;
import it.unibz.inf.tptp.parser.Thf_expression;
import it.unibz.inf.tptp.parser.Thf_formula_type_definition;
import it.unibz.inf.tptp.parser.Thf_root;
import it.unibz.inf.tptp.parser.Thf_type_constant;
import it.unibz.inf.tptp.parser.Thf_var;
import it.unibz.inf.tptp.parser.Thf_var_declaration;
import it.unibz.inf.tptp.parser.Thf_variable_list;
import it.unibz.inf.tptp.parser.binary;
import it.unibz.inf.tptp.parser.oper;
import it.unibz.inf.tptp.services.TPTPGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class TPTPSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private TPTPGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ParserPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ParserPackage.CNF_CONSTANT:
				sequence_Cnf_constant(context, (Cnf_constant) semanticObject); 
				return; 
			case ParserPackage.CNF_EQUALITY:
				sequence_Cnf_equality(context, (Cnf_equality) semanticObject); 
				return; 
			case ParserPackage.CNF_EXPRESSION:
				sequence_Cnf_expression(context, (Cnf_expression) semanticObject); 
				return; 
			case ParserPackage.CNF_FORMULA_TYPE_DEFINITION:
				sequence_Cnf_formula_type_definition(context, (Cnf_formula_type_definition) semanticObject); 
				return; 
			case ParserPackage.CNF_NOT:
				sequence_Cnf_not(context, (Cnf_not) semanticObject); 
				return; 
			case ParserPackage.CNF_OR:
				sequence_Cnf_or(context, (Cnf_or) semanticObject); 
				return; 
			case ParserPackage.CNF_ROOT:
				sequence_Cnf_root(context, (Cnf_root) semanticObject); 
				return; 
			case ParserPackage.CNF_VAR:
				sequence_Cnf_var(context, (Cnf_var) semanticObject); 
				return; 
			case ParserPackage.FOF_CONSTANT:
				if (rule == grammarAccess.getFof_atom_literalRule()) {
					sequence_Fof_atom_literal(context, (Fof_constant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFof_atomRule()) {
					sequence_Fof_atom_literal_Fof_constant(context, (Fof_constant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFof_constantRule()) {
					sequence_Fof_constant(context, (Fof_constant) semanticObject); 
					return; 
				}
				else break;
			case ParserPackage.FOF_EXPRESSION:
				if (rule == grammarAccess.getFof_quantifier_expressionRule()) {
					sequence_Fof_quantifier_expression(context, (Fof_expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFof_expressionRule()
						|| action == grammarAccess.getFof_expressionAccess().getBinaryLeftAction_1_0()
						|| rule == grammarAccess.getFof_terminating_expressionRule()) {
					sequence_Fof_terminating_expression(context, (Fof_expression) semanticObject); 
					return; 
				}
				else break;
			case ParserPackage.FOF_ROOT:
				sequence_Fof_root(context, (Fof_root) semanticObject); 
				return; 
			case ParserPackage.FOF_VAR:
				sequence_Fof_var(context, (Fof_var) semanticObject); 
				return; 
			case ParserPackage.FOF_VARIABLE_LIST:
				sequence_Fof_variable_list(context, (Fof_variable_list) semanticObject); 
				return; 
			case ParserPackage.INCLUDE:
				sequence_Include(context, (Include) semanticObject); 
				return; 
			case ParserPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case ParserPackage.TFF_CONSTANT:
				if (rule == grammarAccess.getTff_atom_literalRule()) {
					sequence_Tff_atom_literal(context, (Tff_constant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTff_atomRule()) {
					sequence_Tff_atom_literal_Tff_constant_Tff_predefined_function_1_args(context, (Tff_constant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTff_constantRule()) {
					sequence_Tff_constant(context, (Tff_constant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTff_predefined_function_1_argsRule()) {
					sequence_Tff_predefined_function_1_args(context, (Tff_constant) semanticObject); 
					return; 
				}
				else break;
			case ParserPackage.TFF_EXPRESSION:
				if (rule == grammarAccess.getTff_quantifier_expressionRule()) {
					sequence_Tff_quantifier_expression(context, (Tff_expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTff_expressionRule()
						|| action == grammarAccess.getTff_expressionAccess().getBinaryLeftAction_1_0()
						|| rule == grammarAccess.getTff_terminating_expressionRule()) {
					sequence_Tff_terminating_expression(context, (Tff_expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTff_type_quantifier_epressionRule()) {
					sequence_Tff_type_quantifier_epression(context, (Tff_expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getThf_quantifier_expressionRule()) {
					sequence_Thf_quantifier_expression(context, (Tff_expression) semanticObject); 
					return; 
				}
				else break;
			case ParserPackage.TFF_FORMULA_TYPE_DEFINITION:
				sequence_Tff_formula_type_definition(context, (Tff_formula_type_definition) semanticObject); 
				return; 
			case ParserPackage.TFF_PREDEFINED_FUNCTION_2ARGS:
				sequence_Tff_predefined_function_2_args(context, (Tff_predefined_function_2_args) semanticObject); 
				return; 
			case ParserPackage.TFF_ROOT:
				sequence_Tff_root(context, (Tff_root) semanticObject); 
				return; 
			case ParserPackage.TFF_TYPE_CONSTANT:
				if (rule == grammarAccess.getTff_type_constantRule()) {
					sequence_Tff_type_constant(context, (Tff_type_constant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTff_type_expressionRule()
						|| action == grammarAccess.getTff_type_expressionAccess().getOperLeftAction_1_0()
						|| rule == grammarAccess.getTff_terminal_type_expressionRule()
						|| rule == grammarAccess.getTff_type_atomRule()) {
					sequence_Tff_type_constant_Tff_type_literal(context, (Tff_type_constant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTff_type_literalRule()) {
					sequence_Tff_type_literal(context, (Tff_type_constant) semanticObject); 
					return; 
				}
				else break;
			case ParserPackage.TFF_VAR:
				sequence_Tff_var(context, (Tff_var) semanticObject); 
				return; 
			case ParserPackage.TFF_VAR_DECLARATION:
				sequence_Tff_var_declaration(context, (Tff_var_declaration) semanticObject); 
				return; 
			case ParserPackage.TFF_VARIABLE_LIST:
				sequence_Tff_variable_list(context, (Tff_variable_list) semanticObject); 
				return; 
			case ParserPackage.THF_CONSTANT:
				if (rule == grammarAccess.getThf_atom_literalRule()) {
					sequence_Thf_atom_literal(context, (Thf_constant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getThf_atomRule()) {
					sequence_Thf_atom_literal_Thf_constant(context, (Thf_constant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getThf_constantRule()) {
					sequence_Thf_constant(context, (Thf_constant) semanticObject); 
					return; 
				}
				else break;
			case ParserPackage.THF_EXPRESSION:
				sequence_Thf_terminating_expression(context, (Thf_expression) semanticObject); 
				return; 
			case ParserPackage.THF_FORMULA_TYPE_DEFINITION:
				sequence_Thf_formula_type_definition(context, (Thf_formula_type_definition) semanticObject); 
				return; 
			case ParserPackage.THF_ROOT:
				sequence_Thf_root(context, (Thf_root) semanticObject); 
				return; 
			case ParserPackage.THF_TYPE_CONSTANT:
				if (rule == grammarAccess.getThf_type_constantRule()) {
					sequence_Thf_type_constant(context, (Thf_type_constant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getThf_type_expressionRule()
						|| action == grammarAccess.getThf_type_expressionAccess().getOperLeftAction_1_0()
						|| rule == grammarAccess.getThf_terminal_type_expressionRule()
						|| rule == grammarAccess.getThf_type_atomRule()) {
					sequence_Thf_type_constant_Thf_type_literal(context, (Thf_type_constant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getThf_type_literalRule()) {
					sequence_Thf_type_literal(context, (Thf_type_constant) semanticObject); 
					return; 
				}
				else break;
			case ParserPackage.THF_VAR:
				sequence_Thf_var(context, (Thf_var) semanticObject); 
				return; 
			case ParserPackage.THF_VAR_DECLARATION:
				sequence_Thf_var_declaration(context, (Thf_var_declaration) semanticObject); 
				return; 
			case ParserPackage.THF_VARIABLE_LIST:
				sequence_Thf_variable_list(context, (Thf_variable_list) semanticObject); 
				return; 
			case ParserPackage.BINARY:
				if (rule == grammarAccess.getFof_expressionRule()
						|| action == grammarAccess.getFof_expressionAccess().getBinaryLeftAction_1_0()
						|| rule == grammarAccess.getFof_terminating_expressionRule()) {
					sequence_Fof_expression(context, (binary) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTff_expressionRule()
						|| action == grammarAccess.getTff_expressionAccess().getBinaryLeftAction_1_0()
						|| rule == grammarAccess.getTff_terminating_expressionRule()) {
					sequence_Tff_expression(context, (binary) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getThf_expressionRule()
						|| action == grammarAccess.getThf_expressionAccess().getBinaryLeftAction_1_0()
						|| rule == grammarAccess.getThf_terminating_expressionRule()) {
					sequence_Thf_expression(context, (binary) semanticObject); 
					return; 
				}
				else break;
			case ParserPackage.OPER:
				if (rule == grammarAccess.getTff_type_expressionRule()
						|| action == grammarAccess.getTff_type_expressionAccess().getOperLeftAction_1_0()
						|| rule == grammarAccess.getTff_terminal_type_expressionRule()) {
					sequence_Tff_type_expression(context, (oper) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getThf_type_expressionRule()
						|| action == grammarAccess.getThf_type_expressionAccess().getOperLeftAction_1_0()
						|| rule == grammarAccess.getThf_terminal_type_expressionRule()) {
					sequence_Thf_type_expression(context, (oper) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Cnf_expression returns Cnf_constant
	 *     Cnf_constant returns Cnf_constant
	 *
	 * Constraint:
	 *     ((name=Lower_token_and_keyword | name=STRING) (param+=Cnf_expression param+=Cnf_expression*)?)
	 */
	protected void sequence_Cnf_constant(ISerializationContext context, Cnf_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Cnf_equality returns Cnf_equality
	 *
	 * Constraint:
	 *     (expL=Cnf_expression ((eq='=' | eq='!=') expR=Cnf_expression)?)
	 */
	protected void sequence_Cnf_equality(ISerializationContext context, Cnf_equality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Cnf_expression returns Cnf_expression
	 *
	 * Constraint:
	 *     cnf_exp=Cnf_statement_literal
	 */
	protected void sequence_Cnf_expression(ISerializationContext context, Cnf_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.CNF_EXPRESSION__CNF_EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.CNF_EXPRESSION__CNF_EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCnf_expressionAccess().getCnf_expCnf_statement_literalParserRuleCall_2_0(), semanticObject.getCnf_exp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Cnf_formula_type_definition returns Cnf_formula_type_definition
	 *
	 * Constraint:
	 *     (disjunction=Cnf_or | disjunction=Cnf_or)
	 */
	protected void sequence_Cnf_formula_type_definition(ISerializationContext context, Cnf_formula_type_definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Cnf_not returns Cnf_not
	 *
	 * Constraint:
	 *     (negated?='~'? literal=Cnf_equality)
	 */
	protected void sequence_Cnf_not(ISerializationContext context, Cnf_not semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Cnf_or returns Cnf_or
	 *
	 * Constraint:
	 *     (or+=Cnf_not or+=Cnf_not*)
	 */
	protected void sequence_Cnf_or(ISerializationContext context, Cnf_or semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Cnf_input returns Cnf_root
	 *     Cnf_root returns Cnf_root
	 *
	 * Constraint:
	 *     (
	 *         (name=Lower_token_and_keyword | name=STRING) 
	 *         (formula_role='axiom' | formula_role='hypothesis' | formula_role='negated_conjecture' | formula_role='plain') 
	 *         exp=Cnf_formula_type_definition
	 *     )
	 */
	protected void sequence_Cnf_root(ISerializationContext context, Cnf_root semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Cnf_expression returns Cnf_var
	 *     Cnf_var returns Cnf_var
	 *
	 * Constraint:
	 *     name=UPPER_TOKEN
	 */
	protected void sequence_Cnf_var(ISerializationContext context, Cnf_var semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.CNF_EXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.CNF_EXPRESSION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCnf_varAccess().getNameUPPER_TOKENTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Fof_atom_literal returns Fof_constant
	 *
	 * Constraint:
	 *     (name='$true' | name='$false')
	 */
	protected void sequence_Fof_atom_literal(ISerializationContext context, Fof_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Fof_atom returns Fof_constant
	 *
	 * Constraint:
	 *     (name='$true' | name='$false' | ((name=Lower_token_and_keyword | name=STRING) (fof_param+=Fof_atom fof_param+=Fof_atom*)?))
	 */
	protected void sequence_Fof_atom_literal_Fof_constant(ISerializationContext context, Fof_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Fof_constant returns Fof_constant
	 *
	 * Constraint:
	 *     ((name=Lower_token_and_keyword | name=STRING) (fof_param+=Fof_atom fof_param+=Fof_atom*)?)
	 */
	protected void sequence_Fof_constant(ISerializationContext context, Fof_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Fof_expression returns binary
	 *     Fof_expression.binary_1_0 returns binary
	 *     Fof_terminating_expression returns binary
	 *
	 * Constraint:
	 *     (left=Fof_expression_binary_1_0 op=Binary_operator right=Fof_terminating_expression)
	 */
	protected void sequence_Fof_expression(ISerializationContext context, binary semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.BINARY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.BINARY__LEFT));
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.THF_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.THF_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.BINARY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.BINARY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFof_expressionAccess().getBinaryLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getFof_expressionAccess().getOpBinary_operatorParserRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getFof_expressionAccess().getRightFof_terminating_expressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Fof_quantifier_expression returns Fof_expression
	 *
	 * Constraint:
	 *     ((fof_quantifier='!' | fof_quantifier='?') fof_param=Fof_variable_list fof_exp=Fof_expression)
	 */
	protected void sequence_Fof_quantifier_expression(ISerializationContext context, Fof_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Fof_input returns Fof_root
	 *     Fof_root returns Fof_root
	 *
	 * Constraint:
	 *     (
	 *         (name=Lower_token_and_keyword | name=STRING) 
	 *         (
	 *             formula_role='axiom' | 
	 *             formula_role='hypothesis' | 
	 *             formula_role='negated_conjecture' | 
	 *             formula_role='conjecture' | 
	 *             formula_role='definition' | 
	 *             formula_role='lemma'
	 *         ) 
	 *         exp=Fof_expression
	 *     )
	 */
	protected void sequence_Fof_root(ISerializationContext context, Fof_root semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Fof_expression returns Fof_expression
	 *     Fof_expression.binary_1_0 returns Fof_expression
	 *     Fof_terminating_expression returns Fof_expression
	 *
	 * Constraint:
	 *     (fof_atom=Fof_atom | (fof_negation?='~' fof_exp=Fof_expression) | fof_exp=Fof_quantifier_expression)
	 */
	protected void sequence_Fof_terminating_expression(ISerializationContext context, Fof_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Fof_atom returns Fof_var
	 *     Fof_var returns Fof_var
	 *
	 * Constraint:
	 *     name=UPPER_TOKEN
	 */
	protected void sequence_Fof_var(ISerializationContext context, Fof_var semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.FOF_ATOM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.FOF_ATOM__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFof_varAccess().getNameUPPER_TOKENTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Fof_variable_list returns Fof_variable_list
	 *
	 * Constraint:
	 *     (params+=Fof_var params+=Fof_var*)
	 */
	protected void sequence_Fof_variable_list(ISerializationContext context, Fof_variable_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Include returns Include
	 *     Fof_input returns Include
	 *     Tff_input returns Include
	 *     Cnf_input returns Include
	 *     Thf_input returns Include
	 *
	 * Constraint:
	 *     path=STRING
	 */
	protected void sequence_Include(ISerializationContext context, Include semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.INCLUDE__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.INCLUDE__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIncludeAccess().getPathSTRINGTerminalRuleCall_2_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (
	 *         TPTP_input+=Include+ | 
	 *         (TPTP_input+=Include+ (TPTP_input+=Fof_input+ | TPTP_input+=Tff_input+ | TPTP_input+=Cnf_input+ | TPTP_input+=Thf_input+))
	 *     )?
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tff_atom_literal returns Tff_constant
	 *
	 * Constraint:
	 *     (name='$true' | name='$false')
	 */
	protected void sequence_Tff_atom_literal(ISerializationContext context, Tff_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tff_atom returns Tff_constant
	 *
	 * Constraint:
	 *     (
	 *         ((name=Lower_token_and_keyword | name=STRING) (param+=Tff_atom param+=Tff_atom*)?) | 
	 *         (top=Lower_token_and_keyword name='/' bottom=Lower_token_and_keyword) | 
	 *         name='$true' | 
	 *         name='$false' | 
	 *         (
	 *             (
	 *                 name='$is_int' | 
	 *                 name='$is_rat' | 
	 *                 name='$uminus' | 
	 *                 name='$to_int' | 
	 *                 name='$to_rat' | 
	 *                 name='$to_real'
	 *             ) 
	 *             param+=Tff_expression
	 *         )
	 *     )
	 */
	protected void sequence_Tff_atom_literal_Tff_constant_Tff_predefined_function_1_args(ISerializationContext context, Tff_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tff_constant returns Tff_constant
	 *
	 * Constraint:
	 *     (
	 *         ((name=Lower_token_and_keyword | name=STRING) (param+=Tff_atom param+=Tff_atom*)?) | 
	 *         (top=Lower_token_and_keyword name='/' bottom=Lower_token_and_keyword)
	 *     )
	 */
	protected void sequence_Tff_constant(ISerializationContext context, Tff_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tff_expression returns binary
	 *     Tff_expression.binary_1_0 returns binary
	 *     Tff_terminating_expression returns binary
	 *
	 * Constraint:
	 *     (left=Tff_expression_binary_1_0 op=Binary_operator right=Tff_terminating_expression)
	 */
	protected void sequence_Tff_expression(ISerializationContext context, binary semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.BINARY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.BINARY__LEFT));
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.THF_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.THF_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.BINARY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.BINARY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTff_expressionAccess().getBinaryLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getTff_expressionAccess().getOpBinary_operatorParserRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getTff_expressionAccess().getRightTff_terminating_expressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Tff_formula_type_definition returns Tff_formula_type_definition
	 *
	 * Constraint:
	 *     ((name=Lower_token_and_keyword | name=STRING) (exp=Tff_type_quantifier_epression | exp=Tff_type_expression))
	 */
	protected void sequence_Tff_formula_type_definition(ISerializationContext context, Tff_formula_type_definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tff_predefined_function_1_args returns Tff_constant
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             name='$is_int' | 
	 *             name='$is_rat' | 
	 *             name='$uminus' | 
	 *             name='$to_int' | 
	 *             name='$to_rat' | 
	 *             name='$to_real'
	 *         ) 
	 *         param+=Tff_expression
	 *     )
	 */
	protected void sequence_Tff_predefined_function_1_args(ISerializationContext context, Tff_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tff_atom returns Tff_predefined_function_2_args
	 *     Tff_predefined_function_2_args returns Tff_predefined_function_2_args
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             func='$less' | 
	 *             func='$sum' | 
	 *             func='$difference' | 
	 *             func='$product' | 
	 *             func='$quotient' | 
	 *             func='$quotient_e' | 
	 *             func='$quotient_t' | 
	 *             func='$quotient_f' | 
	 *             func='$remainder_e' | 
	 *             func='$remainder_t' | 
	 *             func='$remainder_f' | 
	 *             func='$greatereq' | 
	 *             func='$lesseq' | 
	 *             func='$greater' | 
	 *             func='$eq'
	 *         ) 
	 *         param+=Tff_expression 
	 *         param+=Tff_expression
	 *     )
	 */
	protected void sequence_Tff_predefined_function_2_args(ISerializationContext context, Tff_predefined_function_2_args semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tff_quantifier_expression returns Tff_expression
	 *
	 * Constraint:
	 *     ((quantifier='!' | quantifier='?') param=Tff_variable_list exp=Tff_expression)
	 */
	protected void sequence_Tff_quantifier_expression(ISerializationContext context, Tff_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tff_input returns Tff_root
	 *     Tff_root returns Tff_root
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (name=Lower_token_and_keyword | name=STRING) 
	 *             (
	 *                 formula_role='axiom' | 
	 *                 formula_role='hypothesis' | 
	 *                 formula_role='negated_conjecture' | 
	 *                 formula_role='conjecture' | 
	 *                 formula_role='definition' | 
	 *                 formula_role='lemma'
	 *             ) 
	 *             exp=Tff_expression
	 *         ) | 
	 *         ((name=Lower_token_and_keyword | name=STRING) formula_role='type' def=Tff_formula_type_definition)
	 *     )
	 */
	protected void sequence_Tff_root(ISerializationContext context, Tff_root semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tff_expression returns Tff_expression
	 *     Tff_expression.binary_1_0 returns Tff_expression
	 *     Tff_terminating_expression returns Tff_expression
	 *
	 * Constraint:
	 *     (atom=Tff_atom | (negation?='~' exp=Tff_expression) | exp=Tff_quantifier_expression)
	 */
	protected void sequence_Tff_terminating_expression(ISerializationContext context, Tff_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tff_type_constant returns Tff_type_constant
	 *
	 * Constraint:
	 *     ((name=Lower_token_and_keyword | name=STRING) (param+=Tff_type_atom param+=Tff_type_atom*)?)
	 */
	protected void sequence_Tff_type_constant(ISerializationContext context, Tff_type_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tff_type_expression returns Tff_type_constant
	 *     Tff_type_expression.oper_1_0 returns Tff_type_constant
	 *     Tff_terminal_type_expression returns Tff_type_constant
	 *     Tff_type_atom returns Tff_type_constant
	 *
	 * Constraint:
	 *     (
	 *         ((name=Lower_token_and_keyword | name=STRING) (param+=Tff_type_atom param+=Tff_type_atom*)?) | 
	 *         name='$i' | 
	 *         name='$o' | 
	 *         name='$tType' | 
	 *         name='$int' | 
	 *         name='$real' | 
	 *         name='$rat'
	 *     )
	 */
	protected void sequence_Tff_type_constant_Tff_type_literal(ISerializationContext context, Tff_type_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tff_type_expression returns oper
	 *     Tff_type_expression.oper_1_0 returns oper
	 *     Tff_terminal_type_expression returns oper
	 *
	 * Constraint:
	 *     (left=Tff_type_expression_oper_1_0 (op='>' | op='*') right+=Tff_terminal_type_expression)
	 */
	protected void sequence_Tff_type_expression(ISerializationContext context, oper semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tff_type_literal returns Tff_type_constant
	 *
	 * Constraint:
	 *     (
	 *         name='$i' | 
	 *         name='$o' | 
	 *         name='$tType' | 
	 *         name='$int' | 
	 *         name='$real' | 
	 *         name='$rat'
	 *     )
	 */
	protected void sequence_Tff_type_literal(ISerializationContext context, Tff_type_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tff_type_quantifier_epression returns Tff_expression
	 *
	 * Constraint:
	 *     (quantifier='!>' param=Tff_variable_list exp=Tff_type_expression)
	 */
	protected void sequence_Tff_type_quantifier_epression(ISerializationContext context, Tff_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.TFF_EXPRESSION__QUANTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.TFF_EXPRESSION__QUANTIFIER));
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.TFF_EXPRESSION__PARAM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.TFF_EXPRESSION__PARAM));
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.TFF_EXPRESSION__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.TFF_EXPRESSION__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTff_type_quantifier_epressionAccess().getQuantifierExclamationMarkGreaterThanSignKeyword_0_0(), semanticObject.getQuantifier());
		feeder.accept(grammarAccess.getTff_type_quantifier_epressionAccess().getParamTff_variable_listParserRuleCall_2_0(), semanticObject.getParam());
		feeder.accept(grammarAccess.getTff_type_quantifier_epressionAccess().getExpTff_type_expressionParserRuleCall_5_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Tff_type_expression returns Tff_var
	 *     Tff_type_expression.oper_1_0 returns Tff_var
	 *     Tff_terminal_type_expression returns Tff_var
	 *     Tff_type_atom returns Tff_var
	 *     Tff_atom returns Tff_var
	 *     Tff_var returns Tff_var
	 *
	 * Constraint:
	 *     name=UPPER_TOKEN
	 */
	protected void sequence_Tff_var(ISerializationContext context, Tff_var semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.TFF_TYPE_ATOM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.TFF_TYPE_ATOM__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTff_varAccess().getNameUPPER_TOKENTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Tff_var_declaration returns Tff_var_declaration
	 *
	 * Constraint:
	 *     (var=Tff_var vartype=Tff_type_expression)
	 */
	protected void sequence_Tff_var_declaration(ISerializationContext context, Tff_var_declaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.TFF_VAR_DECLARATION__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.TFF_VAR_DECLARATION__VAR));
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.TFF_VAR_DECLARATION__VARTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.TFF_VAR_DECLARATION__VARTYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTff_var_declarationAccess().getVarTff_varParserRuleCall_0_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getTff_var_declarationAccess().getVartypeTff_type_expressionParserRuleCall_2_0(), semanticObject.getVartype());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Tff_variable_list returns Tff_variable_list
	 *
	 * Constraint:
	 *     (params+=Tff_var_declaration params+=Tff_var_declaration*)
	 */
	protected void sequence_Tff_variable_list(ISerializationContext context, Tff_variable_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Thf_atom_literal returns Thf_constant
	 *
	 * Constraint:
	 *     (name='$true' | name='$false')
	 */
	protected void sequence_Thf_atom_literal(ISerializationContext context, Thf_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Thf_atom returns Thf_constant
	 *
	 * Constraint:
	 *     (name='$true' | name='$false' | ((name=Lower_token_and_keyword | name=STRING) (thf_param+=Thf_atom thf_param+=Thf_atom*)?))
	 */
	protected void sequence_Thf_atom_literal_Thf_constant(ISerializationContext context, Thf_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Thf_constant returns Thf_constant
	 *
	 * Constraint:
	 *     ((name=Lower_token_and_keyword | name=STRING) (thf_param+=Thf_atom thf_param+=Thf_atom*)?)
	 */
	protected void sequence_Thf_constant(ISerializationContext context, Thf_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Thf_expression returns binary
	 *     Thf_expression.binary_1_0 returns binary
	 *     Thf_terminating_expression returns binary
	 *
	 * Constraint:
	 *     (left=Thf_expression_binary_1_0 op=Thf_binary_operator right=Thf_terminating_expression)
	 */
	protected void sequence_Thf_expression(ISerializationContext context, binary semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.BINARY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.BINARY__LEFT));
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.THF_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.THF_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.BINARY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.BINARY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getThf_expressionAccess().getBinaryLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getThf_expressionAccess().getOpThf_binary_operatorParserRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getThf_expressionAccess().getRightThf_terminating_expressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Thf_formula_type_definition returns Thf_formula_type_definition
	 *
	 * Constraint:
	 *     ((name=Lower_token_and_keyword | name=STRING) exp=Thf_type_expression)
	 */
	protected void sequence_Thf_formula_type_definition(ISerializationContext context, Thf_formula_type_definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Thf_quantifier_expression returns Tff_expression
	 *
	 * Constraint:
	 *     ((quantifier='!' | quantifier='?' | quantifier='^') param=Thf_variable_list exp=Thf_expression)
	 */
	protected void sequence_Thf_quantifier_expression(ISerializationContext context, Tff_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Thf_input returns Thf_root
	 *     Thf_root returns Thf_root
	 *
	 * Constraint:
	 *     (
	 *         ((name=Lower_token_and_keyword | name=STRING) formula_role='type' def=Thf_formula_type_definition) | 
	 *         (
	 *             (name=Lower_token_and_keyword | name=STRING) 
	 *             (
	 *                 formula_role='axiom' | 
	 *                 formula_role='hypothesis' | 
	 *                 formula_role='negated_conjecture' | 
	 *                 formula_role='conjecture' | 
	 *                 formula_role='definition' | 
	 *                 formula_role='lemma'
	 *             ) 
	 *             thf_exp=Thf_expression
	 *         )
	 *     )
	 */
	protected void sequence_Thf_root(ISerializationContext context, Thf_root semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Thf_expression returns Thf_expression
	 *     Thf_expression.binary_1_0 returns Thf_expression
	 *     Thf_terminating_expression returns Thf_expression
	 *
	 * Constraint:
	 *     (thf_atom=Thf_atom | (thf_negation?='~' thf_exp=Thf_expression) | (op=Thf_unary_operator thf_exp=Thf_expression) | thf_exp=Thf_quantifier_expression)
	 */
	protected void sequence_Thf_terminating_expression(ISerializationContext context, Thf_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Thf_type_constant returns Thf_type_constant
	 *
	 * Constraint:
	 *     (name=Lower_token_and_keyword | name=STRING)
	 */
	protected void sequence_Thf_type_constant(ISerializationContext context, Thf_type_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Thf_type_expression returns Thf_type_constant
	 *     Thf_type_expression.oper_1_0 returns Thf_type_constant
	 *     Thf_terminal_type_expression returns Thf_type_constant
	 *     Thf_type_atom returns Thf_type_constant
	 *
	 * Constraint:
	 *     (name=Lower_token_and_keyword | name=STRING | name='$i' | name='$o' | name='$tType')
	 */
	protected void sequence_Thf_type_constant_Thf_type_literal(ISerializationContext context, Thf_type_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Thf_type_expression returns oper
	 *     Thf_type_expression.oper_1_0 returns oper
	 *     Thf_terminal_type_expression returns oper
	 *
	 * Constraint:
	 *     (left=Thf_type_expression_oper_1_0 op='>' right+=Thf_terminal_type_expression)
	 */
	protected void sequence_Thf_type_expression(ISerializationContext context, oper semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Thf_type_literal returns Thf_type_constant
	 *
	 * Constraint:
	 *     (name='$i' | name='$o' | name='$tType')
	 */
	protected void sequence_Thf_type_literal(ISerializationContext context, Thf_type_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Thf_atom returns Thf_var
	 *     Thf_var returns Thf_var
	 *
	 * Constraint:
	 *     name=UPPER_TOKEN
	 */
	protected void sequence_Thf_var(ISerializationContext context, Thf_var semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.THF_ATOM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.THF_ATOM__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getThf_varAccess().getNameUPPER_TOKENTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Thf_var_declaration returns Thf_var_declaration
	 *
	 * Constraint:
	 *     (var=Thf_var vartype=Thf_type_expression)
	 */
	protected void sequence_Thf_var_declaration(ISerializationContext context, Thf_var_declaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.THF_VAR_DECLARATION__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.THF_VAR_DECLARATION__VAR));
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.THF_VAR_DECLARATION__VARTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.THF_VAR_DECLARATION__VARTYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getThf_var_declarationAccess().getVarThf_varParserRuleCall_0_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getThf_var_declarationAccess().getVartypeThf_type_expressionParserRuleCall_2_0(), semanticObject.getVartype());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Thf_variable_list returns Thf_variable_list
	 *
	 * Constraint:
	 *     (params+=Thf_var_declaration params+=Thf_var_declaration*)
	 */
	protected void sequence_Thf_variable_list(ISerializationContext context, Thf_variable_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
