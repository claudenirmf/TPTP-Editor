/*
 * generated by Xtext 2.12.0
 */
package it.unibz.inf.tptp.serializer;

import com.google.inject.Inject;
import it.unibz.inf.tptp.parser.Model;
import it.unibz.inf.tptp.parser.ParserPackage;
import it.unibz.inf.tptp.parser.binary;
import it.unibz.inf.tptp.parser.cnf_constant;
import it.unibz.inf.tptp.parser.cnf_equality;
import it.unibz.inf.tptp.parser.cnf_expression;
import it.unibz.inf.tptp.parser.cnf_formula_type_definition;
import it.unibz.inf.tptp.parser.cnf_not;
import it.unibz.inf.tptp.parser.cnf_or;
import it.unibz.inf.tptp.parser.cnf_root;
import it.unibz.inf.tptp.parser.cnf_var;
import it.unibz.inf.tptp.parser.fof_constant;
import it.unibz.inf.tptp.parser.fof_expression;
import it.unibz.inf.tptp.parser.fof_root;
import it.unibz.inf.tptp.parser.fof_var;
import it.unibz.inf.tptp.parser.fof_variable_list;
import it.unibz.inf.tptp.parser.include;
import it.unibz.inf.tptp.parser.oper;
import it.unibz.inf.tptp.parser.tff_constant;
import it.unibz.inf.tptp.parser.tff_expression;
import it.unibz.inf.tptp.parser.tff_formula_type_definition;
import it.unibz.inf.tptp.parser.tff_predefined_function_2_args;
import it.unibz.inf.tptp.parser.tff_root;
import it.unibz.inf.tptp.parser.tff_type_constant;
import it.unibz.inf.tptp.parser.tff_var;
import it.unibz.inf.tptp.parser.tff_var_declaration;
import it.unibz.inf.tptp.parser.tff_variable_list;
import it.unibz.inf.tptp.parser.thf_constant;
import it.unibz.inf.tptp.parser.thf_expression;
import it.unibz.inf.tptp.parser.thf_formula_type_definition;
import it.unibz.inf.tptp.parser.thf_root;
import it.unibz.inf.tptp.parser.thf_type_constant;
import it.unibz.inf.tptp.parser.thf_var;
import it.unibz.inf.tptp.parser.thf_var_declaration;
import it.unibz.inf.tptp.parser.thf_variable_list;
import it.unibz.inf.tptp.services.TPTPGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class TPTPSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private TPTPGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ParserPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ParserPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case ParserPackage.BINARY:
				if (rule == grammarAccess.getFof_expressionRule()
						|| action == grammarAccess.getFof_expressionAccess().getBinaryLeftAction_1_0()
						|| rule == grammarAccess.getFof_terminating_expressionRule()) {
					sequence_fof_expression(context, (binary) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTff_expressionRule()
						|| action == grammarAccess.getTff_expressionAccess().getBinaryLeftAction_1_0()
						|| rule == grammarAccess.getTff_terminating_expressionRule()) {
					sequence_tff_expression(context, (binary) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getThf_expressionRule()
						|| action == grammarAccess.getThf_expressionAccess().getBinaryLeftAction_1_0()
						|| rule == grammarAccess.getThf_terminating_expressionRule()) {
					sequence_thf_expression(context, (binary) semanticObject); 
					return; 
				}
				else break;
			case ParserPackage.CNF_CONSTANT:
				sequence_cnf_constant(context, (cnf_constant) semanticObject); 
				return; 
			case ParserPackage.CNF_EQUALITY:
				sequence_cnf_equality(context, (cnf_equality) semanticObject); 
				return; 
			case ParserPackage.CNF_EXPRESSION:
				sequence_cnf_expression(context, (cnf_expression) semanticObject); 
				return; 
			case ParserPackage.CNF_FORMULA_TYPE_DEFINITION:
				sequence_cnf_formula_type_definition(context, (cnf_formula_type_definition) semanticObject); 
				return; 
			case ParserPackage.CNF_NOT:
				sequence_cnf_not(context, (cnf_not) semanticObject); 
				return; 
			case ParserPackage.CNF_OR:
				sequence_cnf_or(context, (cnf_or) semanticObject); 
				return; 
			case ParserPackage.CNF_ROOT:
				sequence_cnf_root(context, (cnf_root) semanticObject); 
				return; 
			case ParserPackage.CNF_VAR:
				sequence_cnf_var(context, (cnf_var) semanticObject); 
				return; 
			case ParserPackage.FOF_CONSTANT:
				if (rule == grammarAccess.getFof_atom_literalRule()) {
					sequence_fof_atom_literal(context, (fof_constant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFof_atomRule()) {
					sequence_fof_atom_literal_fof_constant(context, (fof_constant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFof_constantRule()) {
					sequence_fof_constant(context, (fof_constant) semanticObject); 
					return; 
				}
				else break;
			case ParserPackage.FOF_EXPRESSION:
				if (rule == grammarAccess.getFof_quantifier_expressionRule()) {
					sequence_fof_quantifier_expression(context, (fof_expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFof_expressionRule()
						|| action == grammarAccess.getFof_expressionAccess().getBinaryLeftAction_1_0()
						|| rule == grammarAccess.getFof_terminating_expressionRule()) {
					sequence_fof_terminating_expression(context, (fof_expression) semanticObject); 
					return; 
				}
				else break;
			case ParserPackage.FOF_ROOT:
				sequence_fof_root(context, (fof_root) semanticObject); 
				return; 
			case ParserPackage.FOF_VAR:
				sequence_fof_var(context, (fof_var) semanticObject); 
				return; 
			case ParserPackage.FOF_VARIABLE_LIST:
				sequence_fof_variable_list(context, (fof_variable_list) semanticObject); 
				return; 
			case ParserPackage.INCLUDE:
				sequence_include(context, (include) semanticObject); 
				return; 
			case ParserPackage.OPER:
				if (rule == grammarAccess.getTff_type_expressionRule()
						|| action == grammarAccess.getTff_type_expressionAccess().getOperLeftAction_1_0()
						|| rule == grammarAccess.getTff_terminal_type_expressionRule()) {
					sequence_tff_type_expression(context, (oper) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getThf_type_expressionRule()
						|| action == grammarAccess.getThf_type_expressionAccess().getOperLeftAction_1_0()
						|| rule == grammarAccess.getThf_terminal_type_expressionRule()) {
					sequence_thf_type_expression(context, (oper) semanticObject); 
					return; 
				}
				else break;
			case ParserPackage.TFF_CONSTANT:
				if (rule == grammarAccess.getTff_atom_literalRule()) {
					sequence_tff_atom_literal(context, (tff_constant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTff_atomRule()) {
					sequence_tff_atom_literal_tff_constant_tff_predefined_function_1_args(context, (tff_constant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTff_constantRule()) {
					sequence_tff_constant(context, (tff_constant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTff_predefined_function_1_argsRule()) {
					sequence_tff_predefined_function_1_args(context, (tff_constant) semanticObject); 
					return; 
				}
				else break;
			case ParserPackage.TFF_EXPRESSION:
				if (rule == grammarAccess.getTff_quantifier_expressionRule()) {
					sequence_tff_quantifier_expression(context, (tff_expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTff_expressionRule()
						|| action == grammarAccess.getTff_expressionAccess().getBinaryLeftAction_1_0()
						|| rule == grammarAccess.getTff_terminating_expressionRule()) {
					sequence_tff_terminating_expression(context, (tff_expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTff_type_quantifier_epressionRule()) {
					sequence_tff_type_quantifier_epression(context, (tff_expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getThf_quantifier_expressionRule()) {
					sequence_thf_quantifier_expression(context, (tff_expression) semanticObject); 
					return; 
				}
				else break;
			case ParserPackage.TFF_FORMULA_TYPE_DEFINITION:
				sequence_tff_formula_type_definition(context, (tff_formula_type_definition) semanticObject); 
				return; 
			case ParserPackage.TFF_PREDEFINED_FUNCTION_2ARGS:
				sequence_tff_predefined_function_2_args(context, (tff_predefined_function_2_args) semanticObject); 
				return; 
			case ParserPackage.TFF_ROOT:
				sequence_tff_root(context, (tff_root) semanticObject); 
				return; 
			case ParserPackage.TFF_TYPE_CONSTANT:
				if (rule == grammarAccess.getTff_type_constantRule()) {
					sequence_tff_type_constant(context, (tff_type_constant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTff_type_expressionRule()
						|| action == grammarAccess.getTff_type_expressionAccess().getOperLeftAction_1_0()
						|| rule == grammarAccess.getTff_terminal_type_expressionRule()
						|| rule == grammarAccess.getTff_type_atomRule()) {
					sequence_tff_type_constant_tff_type_literal(context, (tff_type_constant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTff_type_literalRule()) {
					sequence_tff_type_literal(context, (tff_type_constant) semanticObject); 
					return; 
				}
				else break;
			case ParserPackage.TFF_VAR:
				sequence_tff_var(context, (tff_var) semanticObject); 
				return; 
			case ParserPackage.TFF_VAR_DECLARATION:
				sequence_tff_var_declaration(context, (tff_var_declaration) semanticObject); 
				return; 
			case ParserPackage.TFF_VARIABLE_LIST:
				sequence_tff_variable_list(context, (tff_variable_list) semanticObject); 
				return; 
			case ParserPackage.THF_CONSTANT:
				if (rule == grammarAccess.getThf_atom_literalRule()) {
					sequence_thf_atom_literal(context, (thf_constant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getThf_atomRule()) {
					sequence_thf_atom_literal_thf_constant(context, (thf_constant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getThf_constantRule()) {
					sequence_thf_constant(context, (thf_constant) semanticObject); 
					return; 
				}
				else break;
			case ParserPackage.THF_EXPRESSION:
				sequence_thf_terminating_expression(context, (thf_expression) semanticObject); 
				return; 
			case ParserPackage.THF_FORMULA_TYPE_DEFINITION:
				sequence_thf_formula_type_definition(context, (thf_formula_type_definition) semanticObject); 
				return; 
			case ParserPackage.THF_ROOT:
				sequence_thf_root(context, (thf_root) semanticObject); 
				return; 
			case ParserPackage.THF_TYPE_CONSTANT:
				if (rule == grammarAccess.getThf_type_constantRule()) {
					sequence_thf_type_constant(context, (thf_type_constant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getThf_type_expressionRule()
						|| action == grammarAccess.getThf_type_expressionAccess().getOperLeftAction_1_0()
						|| rule == grammarAccess.getThf_terminal_type_expressionRule()
						|| rule == grammarAccess.getThf_type_atomRule()) {
					sequence_thf_type_constant_thf_type_literal(context, (thf_type_constant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getThf_type_literalRule()) {
					sequence_thf_type_literal(context, (thf_type_constant) semanticObject); 
					return; 
				}
				else break;
			case ParserPackage.THF_VAR:
				sequence_thf_var(context, (thf_var) semanticObject); 
				return; 
			case ParserPackage.THF_VAR_DECLARATION:
				sequence_thf_var_declaration(context, (thf_var_declaration) semanticObject); 
				return; 
			case ParserPackage.THF_VARIABLE_LIST:
				sequence_thf_variable_list(context, (thf_variable_list) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (
	 *         TPTP_input+=include+ | 
	 *         (TPTP_input+=include+ (TPTP_input+=fof_input+ | TPTP_input+=tff_input+ | TPTP_input+=cnf_input+ | TPTP_input+=thf_input+))
	 *     )?
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     cnf_expression returns cnf_constant
	 *     cnf_constant returns cnf_constant
	 *
	 * Constraint:
	 *     ((name=lower_token_and_keyword | name=STRING) (param+=cnf_expression param+=cnf_expression*)?)
	 */
	protected void sequence_cnf_constant(ISerializationContext context, cnf_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     cnf_equality returns cnf_equality
	 *
	 * Constraint:
	 *     (expL=cnf_expression ((eq='=' | eq='!=') expR=cnf_expression)?)
	 */
	protected void sequence_cnf_equality(ISerializationContext context, cnf_equality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     cnf_expression returns cnf_expression
	 *
	 * Constraint:
	 *     cnf_exp=cnf_statement_literal
	 */
	protected void sequence_cnf_expression(ISerializationContext context, cnf_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.CNF_EXPRESSION__CNF_EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.CNF_EXPRESSION__CNF_EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCnf_expressionAccess().getCnf_expCnf_statement_literalParserRuleCall_2_0(), semanticObject.getCnf_exp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     cnf_formula_type_definition returns cnf_formula_type_definition
	 *
	 * Constraint:
	 *     (disjunction=cnf_or | disjunction=cnf_or)
	 */
	protected void sequence_cnf_formula_type_definition(ISerializationContext context, cnf_formula_type_definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     cnf_not returns cnf_not
	 *
	 * Constraint:
	 *     (negated?='~'? literal=cnf_equality)
	 */
	protected void sequence_cnf_not(ISerializationContext context, cnf_not semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     cnf_or returns cnf_or
	 *
	 * Constraint:
	 *     (or+=cnf_not or+=cnf_not*)
	 */
	protected void sequence_cnf_or(ISerializationContext context, cnf_or semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     cnf_input returns cnf_root
	 *     cnf_root returns cnf_root
	 *
	 * Constraint:
	 *     (
	 *         (name=lower_token_and_keyword | name=STRING) 
	 *         (formula_role='axiom' | formula_role='hypothesis' | formula_role='negated_conjecture' | formula_role='plain') 
	 *         exp=cnf_formula_type_definition
	 *     )
	 */
	protected void sequence_cnf_root(ISerializationContext context, cnf_root semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     cnf_expression returns cnf_var
	 *     cnf_var returns cnf_var
	 *
	 * Constraint:
	 *     name=UPPER_TOKEN
	 */
	protected void sequence_cnf_var(ISerializationContext context, cnf_var semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.CNF_EXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.CNF_EXPRESSION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCnf_varAccess().getNameUPPER_TOKENTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     fof_atom_literal returns fof_constant
	 *
	 * Constraint:
	 *     (name='$true' | name='$false')
	 */
	protected void sequence_fof_atom_literal(ISerializationContext context, fof_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     fof_atom returns fof_constant
	 *
	 * Constraint:
	 *     (name='$true' | name='$false' | ((name=lower_token_and_keyword | name=STRING) (fof_param+=fof_atom fof_param+=fof_atom*)?))
	 */
	protected void sequence_fof_atom_literal_fof_constant(ISerializationContext context, fof_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     fof_constant returns fof_constant
	 *
	 * Constraint:
	 *     ((name=lower_token_and_keyword | name=STRING) (fof_param+=fof_atom fof_param+=fof_atom*)?)
	 */
	protected void sequence_fof_constant(ISerializationContext context, fof_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     fof_expression returns binary
	 *     fof_expression.binary_1_0 returns binary
	 *     fof_terminating_expression returns binary
	 *
	 * Constraint:
	 *     (left=fof_expression_binary_1_0 op=binary_operator right=fof_terminating_expression)
	 */
	protected void sequence_fof_expression(ISerializationContext context, binary semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.BINARY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.BINARY__LEFT));
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.THF_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.THF_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.BINARY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.BINARY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFof_expressionAccess().getBinaryLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getFof_expressionAccess().getOpBinary_operatorParserRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getFof_expressionAccess().getRightFof_terminating_expressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     fof_quantifier_expression returns fof_expression
	 *
	 * Constraint:
	 *     ((fof_quantifier='!' | fof_quantifier='?') fof_param=fof_variable_list fof_exp=fof_expression)
	 */
	protected void sequence_fof_quantifier_expression(ISerializationContext context, fof_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     fof_input returns fof_root
	 *     fof_root returns fof_root
	 *
	 * Constraint:
	 *     (
	 *         (name=lower_token_and_keyword | name=STRING) 
	 *         (
	 *             formula_role='axiom' | 
	 *             formula_role='hypothesis' | 
	 *             formula_role='negated_conjecture' | 
	 *             formula_role='conjecture' | 
	 *             formula_role='definition' | 
	 *             formula_role='lemma'
	 *         ) 
	 *         exp=fof_expression
	 *     )
	 */
	protected void sequence_fof_root(ISerializationContext context, fof_root semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     fof_expression returns fof_expression
	 *     fof_expression.binary_1_0 returns fof_expression
	 *     fof_terminating_expression returns fof_expression
	 *
	 * Constraint:
	 *     (fof_atom=fof_atom | (fof_negation?='~' fof_exp=fof_expression) | fof_exp=fof_quantifier_expression)
	 */
	protected void sequence_fof_terminating_expression(ISerializationContext context, fof_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     fof_atom returns fof_var
	 *     fof_var returns fof_var
	 *
	 * Constraint:
	 *     name=UPPER_TOKEN
	 */
	protected void sequence_fof_var(ISerializationContext context, fof_var semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.FOF_ATOM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.FOF_ATOM__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFof_varAccess().getNameUPPER_TOKENTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     fof_variable_list returns fof_variable_list
	 *
	 * Constraint:
	 *     (params+=fof_var params+=fof_var*)
	 */
	protected void sequence_fof_variable_list(ISerializationContext context, fof_variable_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     include returns include
	 *     fof_input returns include
	 *     tff_input returns include
	 *     cnf_input returns include
	 *     thf_input returns include
	 *
	 * Constraint:
	 *     path=STRING
	 */
	protected void sequence_include(ISerializationContext context, include semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.INCLUDE__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.INCLUDE__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIncludeAccess().getPathSTRINGTerminalRuleCall_1_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     tff_atom_literal returns tff_constant
	 *
	 * Constraint:
	 *     (name='$true' | name='$false')
	 */
	protected void sequence_tff_atom_literal(ISerializationContext context, tff_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     tff_atom returns tff_constant
	 *
	 * Constraint:
	 *     (
	 *         ((name=lower_token_and_keyword | name=STRING) (param+=tff_atom param+=tff_atom*)?) | 
	 *         (top=lower_token_and_keyword name='/' bottom=lower_token_and_keyword) | 
	 *         name='$true' | 
	 *         name='$false' | 
	 *         (
	 *             (
	 *                 name='$is_int' | 
	 *                 name='$is_rat' | 
	 *                 name='$uminus' | 
	 *                 name='$to_int' | 
	 *                 name='$to_rat' | 
	 *                 name='$to_real'
	 *             ) 
	 *             param+=tff_expression
	 *         )
	 *     )
	 */
	protected void sequence_tff_atom_literal_tff_constant_tff_predefined_function_1_args(ISerializationContext context, tff_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     tff_constant returns tff_constant
	 *
	 * Constraint:
	 *     (
	 *         ((name=lower_token_and_keyword | name=STRING) (param+=tff_atom param+=tff_atom*)?) | 
	 *         (top=lower_token_and_keyword name='/' bottom=lower_token_and_keyword)
	 *     )
	 */
	protected void sequence_tff_constant(ISerializationContext context, tff_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     tff_expression returns binary
	 *     tff_expression.binary_1_0 returns binary
	 *     tff_terminating_expression returns binary
	 *
	 * Constraint:
	 *     (left=tff_expression_binary_1_0 op=binary_operator right=tff_terminating_expression)
	 */
	protected void sequence_tff_expression(ISerializationContext context, binary semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.BINARY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.BINARY__LEFT));
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.THF_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.THF_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.BINARY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.BINARY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTff_expressionAccess().getBinaryLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getTff_expressionAccess().getOpBinary_operatorParserRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getTff_expressionAccess().getRightTff_terminating_expressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     tff_formula_type_definition returns tff_formula_type_definition
	 *
	 * Constraint:
	 *     ((name=lower_token_and_keyword | name=STRING) (exp=tff_type_quantifier_epression | exp=tff_type_expression))
	 */
	protected void sequence_tff_formula_type_definition(ISerializationContext context, tff_formula_type_definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     tff_predefined_function_1_args returns tff_constant
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             name='$is_int' | 
	 *             name='$is_rat' | 
	 *             name='$uminus' | 
	 *             name='$to_int' | 
	 *             name='$to_rat' | 
	 *             name='$to_real'
	 *         ) 
	 *         param+=tff_expression
	 *     )
	 */
	protected void sequence_tff_predefined_function_1_args(ISerializationContext context, tff_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     tff_atom returns tff_predefined_function_2_args
	 *     tff_predefined_function_2_args returns tff_predefined_function_2_args
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             func='$less' | 
	 *             func='$sum' | 
	 *             func='$difference' | 
	 *             func='$product' | 
	 *             func='$quotient' | 
	 *             func='$quotient_e' | 
	 *             func='$quotient_t' | 
	 *             func='$quotient_f' | 
	 *             func='$remainder_e' | 
	 *             func='$remainder_t' | 
	 *             func='$remainder_f' | 
	 *             func='$greatereq' | 
	 *             func='$lesseq' | 
	 *             func='$greater' | 
	 *             func='$eq'
	 *         ) 
	 *         param+=tff_expression 
	 *         param+=tff_expression
	 *     )
	 */
	protected void sequence_tff_predefined_function_2_args(ISerializationContext context, tff_predefined_function_2_args semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     tff_quantifier_expression returns tff_expression
	 *
	 * Constraint:
	 *     ((quantifier='!' | quantifier='?') param=tff_variable_list exp=tff_expression)
	 */
	protected void sequence_tff_quantifier_expression(ISerializationContext context, tff_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     tff_input returns tff_root
	 *     tff_root returns tff_root
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (name=lower_token_and_keyword | name=STRING) 
	 *             (
	 *                 formula_role='axiom' | 
	 *                 formula_role='hypothesis' | 
	 *                 formula_role='negated_conjecture' | 
	 *                 formula_role='conjecture' | 
	 *                 formula_role='definition' | 
	 *                 formula_role='lemma'
	 *             ) 
	 *             exp=tff_expression
	 *         ) | 
	 *         ((name=lower_token_and_keyword | name=STRING) formula_role='type' def=tff_formula_type_definition)
	 *     )
	 */
	protected void sequence_tff_root(ISerializationContext context, tff_root semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     tff_expression returns tff_expression
	 *     tff_expression.binary_1_0 returns tff_expression
	 *     tff_terminating_expression returns tff_expression
	 *
	 * Constraint:
	 *     (atom=tff_atom | (negation?='~' exp=tff_expression) | exp=tff_quantifier_expression)
	 */
	protected void sequence_tff_terminating_expression(ISerializationContext context, tff_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     tff_type_constant returns tff_type_constant
	 *
	 * Constraint:
	 *     ((name=lower_token_and_keyword | name=STRING) (param+=tff_type_atom param+=tff_type_atom*)?)
	 */
	protected void sequence_tff_type_constant(ISerializationContext context, tff_type_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     tff_type_expression returns tff_type_constant
	 *     tff_type_expression.oper_1_0 returns tff_type_constant
	 *     tff_terminal_type_expression returns tff_type_constant
	 *     tff_type_atom returns tff_type_constant
	 *
	 * Constraint:
	 *     (
	 *         ((name=lower_token_and_keyword | name=STRING) (param+=tff_type_atom param+=tff_type_atom*)?) | 
	 *         name='$i' | 
	 *         name='$o' | 
	 *         name='$tType' | 
	 *         name='$int' | 
	 *         name='$real' | 
	 *         name='$rat'
	 *     )
	 */
	protected void sequence_tff_type_constant_tff_type_literal(ISerializationContext context, tff_type_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     tff_type_expression returns oper
	 *     tff_type_expression.oper_1_0 returns oper
	 *     tff_terminal_type_expression returns oper
	 *
	 * Constraint:
	 *     (left=tff_type_expression_oper_1_0 (op='>' | op='*') right+=tff_terminal_type_expression)
	 */
	protected void sequence_tff_type_expression(ISerializationContext context, oper semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     tff_type_literal returns tff_type_constant
	 *
	 * Constraint:
	 *     (
	 *         name='$i' | 
	 *         name='$o' | 
	 *         name='$tType' | 
	 *         name='$int' | 
	 *         name='$real' | 
	 *         name='$rat'
	 *     )
	 */
	protected void sequence_tff_type_literal(ISerializationContext context, tff_type_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     tff_type_quantifier_epression returns tff_expression
	 *
	 * Constraint:
	 *     (quantifier='!>' param=tff_variable_list exp=tff_type_expression)
	 */
	protected void sequence_tff_type_quantifier_epression(ISerializationContext context, tff_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.TFF_EXPRESSION__QUANTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.TFF_EXPRESSION__QUANTIFIER));
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.TFF_EXPRESSION__PARAM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.TFF_EXPRESSION__PARAM));
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.TFF_EXPRESSION__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.TFF_EXPRESSION__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTff_type_quantifier_epressionAccess().getQuantifierExclamationMarkGreaterThanSignKeyword_0_0(), semanticObject.getQuantifier());
		feeder.accept(grammarAccess.getTff_type_quantifier_epressionAccess().getParamTff_variable_listParserRuleCall_2_0(), semanticObject.getParam());
		feeder.accept(grammarAccess.getTff_type_quantifier_epressionAccess().getExpTff_type_expressionParserRuleCall_5_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     tff_var_declaration returns tff_var_declaration
	 *
	 * Constraint:
	 *     (var=tff_var vartype=tff_type_expression)
	 */
	protected void sequence_tff_var_declaration(ISerializationContext context, tff_var_declaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.TFF_VAR_DECLARATION__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.TFF_VAR_DECLARATION__VAR));
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.TFF_VAR_DECLARATION__VARTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.TFF_VAR_DECLARATION__VARTYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTff_var_declarationAccess().getVarTff_varParserRuleCall_0_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getTff_var_declarationAccess().getVartypeTff_type_expressionParserRuleCall_2_0(), semanticObject.getVartype());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     tff_type_expression returns tff_var
	 *     tff_type_expression.oper_1_0 returns tff_var
	 *     tff_terminal_type_expression returns tff_var
	 *     tff_type_atom returns tff_var
	 *     tff_atom returns tff_var
	 *     tff_var returns tff_var
	 *
	 * Constraint:
	 *     name=UPPER_TOKEN
	 */
	protected void sequence_tff_var(ISerializationContext context, tff_var semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.TFF_TYPE_ATOM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.TFF_TYPE_ATOM__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTff_varAccess().getNameUPPER_TOKENTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     tff_variable_list returns tff_variable_list
	 *
	 * Constraint:
	 *     (params+=tff_var_declaration params+=tff_var_declaration*)
	 */
	protected void sequence_tff_variable_list(ISerializationContext context, tff_variable_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     thf_atom_literal returns thf_constant
	 *
	 * Constraint:
	 *     (name='$true' | name='$false')
	 */
	protected void sequence_thf_atom_literal(ISerializationContext context, thf_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     thf_atom returns thf_constant
	 *
	 * Constraint:
	 *     (name='$true' | name='$false' | ((name=lower_token_and_keyword | name=STRING) (thf_param+=thf_atom thf_param+=thf_atom*)?))
	 */
	protected void sequence_thf_atom_literal_thf_constant(ISerializationContext context, thf_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     thf_constant returns thf_constant
	 *
	 * Constraint:
	 *     ((name=lower_token_and_keyword | name=STRING) (thf_param+=thf_atom thf_param+=thf_atom*)?)
	 */
	protected void sequence_thf_constant(ISerializationContext context, thf_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     thf_expression returns binary
	 *     thf_expression.binary_1_0 returns binary
	 *     thf_terminating_expression returns binary
	 *
	 * Constraint:
	 *     (left=thf_expression_binary_1_0 op=thf_binary_operator right=thf_terminating_expression)
	 */
	protected void sequence_thf_expression(ISerializationContext context, binary semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.BINARY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.BINARY__LEFT));
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.THF_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.THF_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.BINARY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.BINARY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getThf_expressionAccess().getBinaryLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getThf_expressionAccess().getOpThf_binary_operatorParserRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getThf_expressionAccess().getRightThf_terminating_expressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     thf_formula_type_definition returns thf_formula_type_definition
	 *
	 * Constraint:
	 *     ((name=lower_token_and_keyword | name=STRING) exp=thf_type_expression)
	 */
	protected void sequence_thf_formula_type_definition(ISerializationContext context, thf_formula_type_definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     thf_quantifier_expression returns tff_expression
	 *
	 * Constraint:
	 *     ((quantifier='!' | quantifier='?' | quantifier='^') param=thf_variable_list exp=thf_expression)
	 */
	protected void sequence_thf_quantifier_expression(ISerializationContext context, tff_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     thf_input returns thf_root
	 *     thf_root returns thf_root
	 *
	 * Constraint:
	 *     (
	 *         ((name=lower_token_and_keyword | name=STRING) formula_role='type' def=thf_formula_type_definition) | 
	 *         (
	 *             (name=lower_token_and_keyword | name=STRING) 
	 *             (
	 *                 formula_role='axiom' | 
	 *                 formula_role='hypothesis' | 
	 *                 formula_role='negated_conjecture' | 
	 *                 formula_role='conjecture' | 
	 *                 formula_role='definition' | 
	 *                 formula_role='lemma'
	 *             ) 
	 *             thf_exp=thf_expression
	 *         )
	 *     )
	 */
	protected void sequence_thf_root(ISerializationContext context, thf_root semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     thf_expression returns thf_expression
	 *     thf_expression.binary_1_0 returns thf_expression
	 *     thf_terminating_expression returns thf_expression
	 *
	 * Constraint:
	 *     (thf_atom=thf_atom | (thf_negation?='~' thf_exp=thf_expression) | (op=thf_unary_operator thf_exp=thf_expression) | thf_exp=thf_quantifier_expression)
	 */
	protected void sequence_thf_terminating_expression(ISerializationContext context, thf_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     thf_type_constant returns thf_type_constant
	 *
	 * Constraint:
	 *     (name=lower_token_and_keyword | name=STRING)
	 */
	protected void sequence_thf_type_constant(ISerializationContext context, thf_type_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     thf_type_expression returns thf_type_constant
	 *     thf_type_expression.oper_1_0 returns thf_type_constant
	 *     thf_terminal_type_expression returns thf_type_constant
	 *     thf_type_atom returns thf_type_constant
	 *
	 * Constraint:
	 *     (name=lower_token_and_keyword | name=STRING | name='$i' | name='$o' | name='$tType')
	 */
	protected void sequence_thf_type_constant_thf_type_literal(ISerializationContext context, thf_type_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     thf_type_expression returns oper
	 *     thf_type_expression.oper_1_0 returns oper
	 *     thf_terminal_type_expression returns oper
	 *
	 * Constraint:
	 *     (left=thf_type_expression_oper_1_0 op='>' right+=thf_terminal_type_expression)
	 */
	protected void sequence_thf_type_expression(ISerializationContext context, oper semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     thf_type_literal returns thf_type_constant
	 *
	 * Constraint:
	 *     (name='$i' | name='$o' | name='$tType')
	 */
	protected void sequence_thf_type_literal(ISerializationContext context, thf_type_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     thf_var_declaration returns thf_var_declaration
	 *
	 * Constraint:
	 *     (var=thf_var vartype=thf_type_expression)
	 */
	protected void sequence_thf_var_declaration(ISerializationContext context, thf_var_declaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.THF_VAR_DECLARATION__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.THF_VAR_DECLARATION__VAR));
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.THF_VAR_DECLARATION__VARTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.THF_VAR_DECLARATION__VARTYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getThf_var_declarationAccess().getVarThf_varParserRuleCall_0_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getThf_var_declarationAccess().getVartypeThf_type_expressionParserRuleCall_2_0(), semanticObject.getVartype());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     thf_atom returns thf_var
	 *     thf_var returns thf_var
	 *
	 * Constraint:
	 *     name=UPPER_TOKEN
	 */
	protected void sequence_thf_var(ISerializationContext context, thf_var semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ParserPackage.Literals.THF_ATOM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.THF_ATOM__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getThf_varAccess().getNameUPPER_TOKENTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     thf_variable_list returns thf_variable_list
	 *
	 * Constraint:
	 *     (params+=thf_var_declaration params+=thf_var_declaration*)
	 */
	protected void sequence_thf_variable_list(ISerializationContext context, thf_variable_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
